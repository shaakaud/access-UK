#!/usr/bin/perl
#**************************************************************************
#   This file was generated from a tool and
#   is subject to change.  Do not edit this file
#   directly, if you want to maintain any changes.
# 
#   Author: Amod Deshpande
# 
#   Copyright (c) 2014-2016 Alcatel-Lucent
# 
# $Id: Exp $
#**************************************************************************
package regressParams;
use strict;
use lib '/usr/local/timostools/perllib';
use IO::File;
use File::Path;
use File::Basename;
use Net::Telnet;
use Cwd;
our %regressParams = ();
sub getRegressParams
{
my $lab = "";
my $rpfile = getRegressParamsLocation();
printf("Reading testbed params ....\n");
my $fd = new IO::File;
unless( open($fd, "< $rpfile") ){
die("Unable to open $rpfile\n");
}
my @data = <$fd>;
close($fd);
shift(@data);
foreach my $line (@data) {
chomp($line);
unless( $line =~ /^$main::site/ ) {
next;
}
unless( $line =~ /SITE/ 
|| $line =~ /ACCESS/ 
|| $line =~ /DESCRIPTION/
|| $line =~ /ALLOW_RUNLEVELS/
|| $line =~ /SUBTOPO/ 
|| $line =~ /DENY_SUBTOPOS/ 
) {
next;
}
if( $main::dflag) { printf("Working on: $line\n"); }
$line =~ s/\s+/\;/g;    
my @values = split(';', $line);
$lab = $values[0];
if( $lab =~ /scale/
|| $lab =~ /gash/ 
|| $lab =~ /cli/ 
|| $lab =~ /endur/ ) {
next;
}
if( $main::dflag) { printf("Working on: $lab\n"); }
if( $line =~ /;SITE;/ ) {
$regressParams{$lab}{'lab'} = $lab;
$regressParams{$lab}{'type'} = "ANY"; 
$regressParams{$lab}{'allowed'} = 1;    
$regressParams{$lab}{'topology'} = "ANY"; 
$regressParams{$lab}{'deny'} = "ANY"; 
next;
}
if( $line =~ /;DESCRIPTION;/ ) {
if( $line =~ /Hardware/ ) {
$regressParams{$lab}{'type'} = "HW";
next;
}
if( $line =~ /VM;Support/ || $line =~ /VM;support/) {
$regressParams{$lab}{'type'} = "VM";
next;
}
if( $line =~ /SimPC/ ) {
$regressParams{$lab}{'type'} = "SIM";
next;
}
$regressParams{$lab}{'type'} = "UNK";
}
if( $line =~ /;SUBTOPO;/ ) {
$regressParams{$lab}{'topology'} = $values[2];
next;
}
if( $line =~ /;DENY_SUBTOPOS;/ ) {
my $deny = $line;
$deny =~ s/$lab//g;     
$deny =~ s/;DENY_SUBTOPOS;//g;
$regressParams{$lab}{'deny'} = $deny;
next;
}
if( $line =~ /;ALLOW_RUNLEVELS;/ ) {
$regressParams{$lab}{'allowed'} = 0;
next;
}
if( $line =~ /;ACCESS;/ && $line =~ /private/) {
$regressParams{$lab}{'allowed'} = 0;
next;
}
}
if( $main::dflag) {
dumpRegressParams();
}
}
sub getRegressParamsLocation
{
my $rpext = "regress.params";
if( main::globalRoot() ) {
my $rpfile = "$main::root/$rpext";
if( -e $rpfile ) {
return($rpfile);
}
}
my $timosRegress = "/usr/local/timostools/regress.params";
if( -e $timosRegress ) {
return($timosRegress);
}
die("regress.params not found\n");
}
sub dumpRegressParams
{
my $count = 0;
foreach my $lab (keys %regressParams) {
printf("%d: $regressParams{$lab}{'lab'} : $regressParams{$lab}{'type'} : $regressParams{$lab}{'topology'} : $regressParams{$lab}{'deny'} : $regressParams{$lab}{'allowed'}\n", $count++);
}
}
sub getRegressionStatus
{
my $tbfile = shift;
my $state = shift;
my @lines = ();
if( main::globalRoot() ) {
@lines = `ls /usr/global/regression/$state`;
} else {
my $t = new Net::Telnet ( Errmode => 'return' );
$t->open($main::server);
if($t->errmsg ) {
die("Error: $t->errmsg \n");
} 
$t->login($main::login, $main::passwd);
@lines = $t->cmd("ls /usr/global/regression/$state");
}
my $fd = new IO::File;
unless( open($fd, "> $tbfile") ){
die("Unable to open $tbfile to write\n");
}
print $fd "@lines";
if($main::dflag){printf("$state:\n");print "@lines"; printf("\n");}
close $fd;
}
1;
package testBeds;
use strict;
use IO::File;
use File::Path;
use File::Basename;
use Cwd;
our @vmtestbed = ();
our @hwtestbed = ();
our @simtestbed = ();
our $select = 0;    
our $tcount = 0;
our $vmtcount = 0;
our $hwtcount = 0;
our $simtcount = 0;
our $vmstatus = "";
our $hwstatus = "";
our $simstatus = "";
my $tbfile = "/tmp/testbed$$.status";
my $blacklist = "blacklistTB.txt";
my $osName=`/bin/uname -s`;
chomp($osName);
my $vmidle = 0;
my $hwidle = 0;
my $simidle = 0;
sub findTestBeds
{
if( $main::dflag) {printf("My OS is $osName\n");}
printf("Finding idle testbeds....\n");
if( isVmAllowed() ) {
doit("idle", "VM");
if($vmtcount == 0 ) {
printf("No idle VM testbeds available - looking for inprogress VM\n");
doit("inprogress", "VM");
} else {
$vmidle = 1;    
}
}
if( isHwAllowed() ) {
doit("idle", "HW");
if($hwtcount == 0 ) {
printf("No idle HW testbeds available - looking for inprogress HW\n");
doit("inprogress", "HW");
} else {
$hwidle = 1;    
}
}
if( isSimAllowed() ) {
doit("idle", "SIM");
if($simtcount == 0 ) {
printf("No idle SIM testbeds available - looking for inprogress SIM\n");
doit("inprogress", "SIM");
} else {
$simidle = 1;   
}
}
$tcount = $vmtcount + $hwtcount + $simtcount;
if($tcount == 0 ) {
die("No testbeds are idle or inprogress - please check later\n");
} 
#my @a = sort {$a <=> $b} @testbed;
my @a = sort {$a cmp $b} @vmtestbed;
@vmtestbed = @a;
my @a = sort {$a cmp $b} @hwtestbed;
@hwtestbed = @a;
my @a = sort {$a cmp $b} @simtestbed;
@simtestbed = @a;
if( $main::showtb ) {
my $index = 1;
if( isVmAllowed() ) {
printf("\n\n\t\tVM Testbeds ($vmstatus):\n\t\t");
for my $i (0 .. $#vmtestbed ) {
printf("%2d) %-15s", $index, $vmtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
}
if( isHwAllowed() ) {
printf("\n\n\t\tHW Testbeds ($hwstatus):\n\t\t");
for my $i (0 .. $#hwtestbed ) {
printf("%2d) %-15s", $index, $hwtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
}
if( isSimAllowed() ) {
printf("\n\n\t\tSIM Testbeds ($simstatus):\n\t\t");
for my $i (0 .. $#simtestbed ) {
printf("%2d) %-15s", $index, $simtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
printf("\n\n");
exit;
}
}
}
sub doit
{
my $status = shift;
my $tbtype = shift;
regressParams::getRegressionStatus($tbfile, $status);
my $fd = new IO::File;
unless( open($fd, "< $tbfile") ){
die("Unable to open $tbfile to read\n");
}
while( <$fd> ) {
chomp($_);
my $line = $_;
if( $line =~ /\[/ ) {
next;
}
$line =~ s/\s+/\;/g;    
if( $main::dflag) { printf("TBED: $line\n");}
my %values = split(';', $line);
foreach my $tbed (%values) {
unless($tbed) {
next;
}
if( $main::dflag) { printf("testbed $tbtype: $tbed  "); }
if( $tbed =~ /^$main::site/ ) {
if( isAllowed($tbed) ) {
if( $tbtype eq "VM" && isVmTb($tbed) && isAlive($tbed) ) {
$vmtestbed[$vmtcount++] = $tbed;
$tbtype = "VM";
$vmstatus = $status;
$vmstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
} 
if ( $tbtype eq "HW" && isHwTb($tbed) && isAlive($tbed) ) {
$hwtestbed[$hwtcount++] = $tbed;
$tbtype = "HW";
$hwstatus = $status;
$hwstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
} 
if ( $tbtype eq "SIM" && isSimTb($tbed) && isAlive($tbed) ) {
$simtestbed[$simtcount++] = $tbed;
$tbtype = "SIM";
$simstatus = $status;
$simstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
}
if( $main::dflag) { printf("Ignore - VM, HW, SIM check failed\n"); }
next;
}
}
if( $main::dflag) { printf("Not allowed\n"); }
}
}
close($fd);
unlink($tbfile);
}
sub isVmAllowed
{
if( $main::hwonly == 1 || $main::simonly == 1) {
return(0);
}
return(1);
}
sub isHwAllowed
{
if( $main::vmonly == 1 || $main::simonly == 1 || $main::allowhw == 0 || $runSuite::vfp == 1) {
return(0);
}
return(1);
}
sub isSimAllowed
{
if( $main::hwonly == 1 || $main::vmonly == 1 || $runSuite::vfp == 1) {
return(0);
}
return(1);
}
sub isVmTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "VM" ) {
return(1);
}
return(0);
}
sub isHwTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "HW" ) {
return(1);
}
return(0);
}
sub isSimTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "SIM" ) {
return(1);
}
return(0);
}
sub isAllowed
{
my $host = shift;
if( $select ) {
return(1);
}
if( $host =~ /scale/
|| $host =~ /gash/ 
|| $host =~ /cli/ 
|| $host =~ /red/ 
|| $host =~ /endur/ ) {
return(0);
}
if( isBlackList( $host ) ) {
return(0);
}
if( $regressParams::regressParams{$host}{'allowed'} == 0 ) {
return(0);
}
if( isHwTb($host) ) {
if( $main::subTopology =~ /$regressParams::regressParams{$host}{'deny'}/ ) {
return(0);
}
if( $main::subTopology eq $regressParams::regressParams{$host}{'topology'} ) {
return(1);
}
if( "ANY" eq $regressParams::regressParams{$host}{'topology'} ) {
return(1);
}
return(0);
}
return(1);
}
sub isAlive
{
my $host = shift;
if( $main::dryOnly || $main::showtb || $main::noping ) {
return(1);
}
my $rc = _isAlive($host);
return($rc);
}
sub _isAlive
{
my $host = shift;
my $fd = "";
if($osName ne "Linux"){
$fd = new IO::File("ping $host -n 2 | grep \"Received = 2\"  2>/dev/null |");
} else {
$fd = new IO::File("/bin/ping -c 2 -W 20 $host | grep \"[12] received\" 2>/dev/null |");
}
unless( $fd ) {
if( $main::dflag) {printf("Ping failed to host: $host\n");}
return(0);
}
my $rc = <$fd>;
chomp($rc);
if ( $rc =~ /[a-z]/i ) {
if( $main::dflag) {printf("Ping success to host: $host\n");}
return(1);
}
return(0);
}
my %blackList = ();
sub readBlacklist
{
my $file = "";
if( -e "/home/$main::user/$blacklist" ) {
$file = "/home/$main::user/$blacklist";
}
if( -e $blacklist ) {
$file = $blacklist;
}
if( -e "$main::root/$blacklist" ) {
$file = "$main::root/$blacklist";
}
if( -e "/tmp/$blacklist" ) {
$file = "/tmp/$blacklist";
}
unless ($file ) {
if( $main::dflag) { printf("No blacklist file\n"); }
return;
}
my @contents = `cat $file 2> /dev/null`;
foreach my $line (@contents) {
chomp($line);
$blackList{$line} = 1;
if( $main::dflag) { printf("$line is blacklist TB\n"); }
}
}
sub isBlackList
{
my $tb = shift;
if( $blackList{$tb} ) {
return 1;
}
return 0;
}
sub selectTestBed
{
my $tbtype = shift;
my $index = 1;
my $cntr = 1;
if( isVmAllowed() && ($tbtype eq "ANY" || $tbtype eq "VM") ) {
printf("\n\n\t\tVM Testbeds ($vmstatus):\n\t\t");
for my $choice (@vmtestbed) {
printf("%2d) %-15s", $index, $vmtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
if( isHwAllowed() && ($tbtype eq "ANY" || $tbtype eq "HW") ) {
$cntr = 1;
printf("\n\n\t\tHW Testbeds ($hwstatus):\n\t\t");
for my $choice (@hwtestbed) {
printf("%2d) %-15s", $index, $hwtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
if( isSimAllowed() && ($tbtype eq "ANY" || $tbtype eq "SIM") ) {
$cntr = 1;
printf("\n\n\t\tSIM Testbeds ($simstatus):\n\t\t");
for my $choice (@simtestbed) {
printf("%2d) %-15s", $index, $simtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
print "\n\n\t\tEnter your Testbed choice: ";
my $choice = <STDIN>;
chomp($choice);
unless( $choice > 0 && $choice < $index ) {
printf("\t\tInvalid input $choice - please try later\n");
return("");
}
if( $choice <= $vmtcount ) {
if( $main::dflag) {printf("User selected VM $choice - Returning $vmtestbed[$choice - 1]\n" );}
return($vmtestbed[$choice - 1]);
} 
if( $choice > $vmtcount && $choice <= ($vmtcount + $hwtcount)) {
if( $main::dflag) {printf("User selected HW $choice\n" );}
$choice = $choice - $vmtcount;
if( $main::dflag) {printf("HW Selection: $choice (VM $vmtcount) - Returning $hwtestbed[$choice - 1]\n" );}
return($hwtestbed[$choice - 1]);
} 
if( $main::dflag) {printf("User selected SIM $choice\n" );}
$choice = $choice - $vmtcount - $hwtcount;
if( $main::dflag) {printf("SIM Selection: $choice (VM $vmtcount HW $hwtcount) -  Returning $simtestbed[$choice - 1]\n" );}
return($simtestbed[$choice - 1]);
}
my $lastvm = 0;
my $lasthw = 0;
my $lastsim = 0;
sub getTestBed
{
my $tbtype = shift;
if( $tbtype eq "ANY" ) {
if( ($lastvm + $lasthw + $lastsim) >= $tcount ) {
$lastvm = $lastsim = $lasthw = 0;
}
if( $vmidle == 0 && $hwidle == 0 && $simidle == 0 ) {
return( selectTestBed($tbtype) );
}
if( $vmtcount && $lastvm <= ($vmtcount-1) ) {
return($vmtestbed[$lastvm++]);
}
if( $simtcount && $lastsim <= ($simtcount-1) ) {
return($simtestbed[$lastsim++]);
}
if( $hwtcount && $lasthw <= ($hwtcount-1) ) {
return($hwtestbed[$lasthw++]);
}
}
if( $tbtype eq "VM" ) {
if( $lastvm >= $vmtcount ) {
$lastvm = 0;
}
if( $vmidle == 0 ) {
return( selectTestBed($tbtype) );
}
if( $vmtcount && $lastvm <= ($vmtcount-1) ) {
return($vmtestbed[$lastvm++]);
}
}
if( $tbtype eq "HW" ) {
if( $lasthw >= $hwtcount ) {
$lasthw = 0;
}
if( $hwidle == 0 ) {
return( selectTestBed($tbtype) );
}
if( $hwtcount && $lasthw <= ($hwtcount-1) ) {
return($hwtestbed[$lasthw++]);
}
}
if( $tbtype eq "SIM" ) {
if( $lastsim >= $simtcount ) {
$lastsim = 0;
}
if( $simidle == 0 ) {
return( selectTestBed($tbtype) );
}
if( $simtcount && $lastsim <= ($simtcount-1) ) {
return($simtestbed[$lastsim++]);
}
}
return ("");
}
1;
package runSuite;
use strict;
use Cwd;
my $rfile = "/tmp/regress$$.status";
my $multiRun = 0;   
our $vfp = 0;        
our @express = ( 
"express-express",
);
our @quickonly = ( 
"mgExpress-quick",
);
our @quick = ( 
"mgQuick-quickOnly",
);
our @basic = ( 
"express-express",
"mgQuick-quickOnly",
);
our @basic1 = ( 
"mgExpress-quickOnly",
"mgCli-express",
"mgQuickSgwIcr-quickOnly",
"mmeGracefulRestart-quickOnly",
"gaQuick-quickOnly",
);
our @vfpBasic = ( 
"express-express",
"mgQuick-quickOnly",
);
our @general = (
"lteCallFlows-medium",
"lteMBCmdSgwPgw-regular",
"ltePathMgmtSgwPgw-regular",
"ltePiggybackSgwPgw-regular",
"gyMidSessionRgChg-regular"
);
our @ggsn = (
"ggsnCallFlows-medium",
"ggsnIdleSesTimeout-regular",
"ggsnIdleSesTimeout_GTPv0-regular",
"ggsnRadIdleSesTimeoutMApn-regular"
);
our @pmip = (
"pgwPmipS2aCallFlowsLteEhrpdCombo-regular",
"pgwPmipS2aQos-regular",
"pgwPmipS2aCallFlowsHA-regular",
"pmipDedBearers-regular",
"pmipDedBearersHA-regular",
"pmipPgwRf-regular",
"ehrpdPgwTests-medium",
"pgwPmipS2aCallFlows-regular",
"pgwPmipS2aCallFlowInteractions-regular"
);
our @combo =  (
"sccgIratCallFlows-regular",
"sccgIratCallFlowsHA-regular",
"sccgS11CallFlows-regular",
"sccgMiscFeatures-regular",
"sccgS11CallFlowsICR-regular", 
"sccgS2aIratCallFlows-regular",
"sccgS11CallFlowsICRWithHA-regular ",
"sccgS11ICRTrafficDetection-regular"
);
our @ubreq = (
"UpdateBearerSgwPgw-regular",
"lteS4S12nwInit-regular"
);
our @dbreq = (
"lteS4S12Vprn-regular",
"createDeleteDedBearersSgwPgw-regular"
);
our @spgwho  = (
"handoverSgwPgw-regular",
"s1HandoverSgwPgw-regular",
"s1HandoverV6SgwPgw-regular",
"multiplePdnHandover-regular",
);
our @sgwrelo =  (
"s1HandoverRelocation-regular",
"multiApnS1HOReloc-regular",
"x2HandoverRelocation-regular",
"multiApnS1HORelocV6-regular",
"mmeRelocNoSGWReloc-regular"
);
our @mmerelo  = (
"mmeRelocNoSGWRelocHA-regular"
);
our @paging = (
"pagingSgwOnly-regular",
"pagingSgwPgw-regular",
"pagingMpdn-regular",
"pagingMpdnIdleToActive-regular",
"pagingMpdnIdleToActiveHA-regular"
);
our @idlesesstimeout = (
"lteRadIdleSesTimeout-regular",
"pgwGaIdleSesTimeout-regular",
"lteIdleSesTimeout-regular"
);
our @s2b = (
"lteS2bCallFlows-regular",
"s2bLteIRATHandover-regular",
"s2b3gLteCcauPendingICR-regular",
"s2bTo3gHoRatWlanICR-regular",
"pgwS6bS2bVzWCallFlows-extensive"
);
our @redicr = (
"mgRedundancyAll-medium",
"pgwIcrCallFlows-regular",
"lteGeoRedundancy-medium"
);
our @irat = ( 
"gnGxInterRatGprsLte-regular",
"ggsnUpdatePdp-regular",
"interRatGprsLteSgwHA-regular",
"ggsnCallFlowsHA-regular",
"interRatGprsLte-regular",
"interRatGprsLteMultiBr-regular",
"s2bLteIRATHandover-regular",
"s2bLteIRATHoWithHA-regular"
);
our @li = (
"Li_CallFlows-regular",
"lteLiSgwPgwAll-regular",
"lteLiGGSN-regular",
"lteLiGgsnMsisdn-regular",
"lteLiGgsnMultipleTargets-regular"
);
our @timeofday = (
"lteGxTimeOfDay-regular",
"lteGxTimeOfDayGeoRed-regular",
"lteGxTimeOfDayScaling-regular"
);
our @usage = (
"gxUsgMonitorAll-regular",
"gxRuleLevelUsageMonitoring-regular",
"gxRuleLevelUsageMonitoringWithRf-regular",
"gxRuleReferenceUsageMonitoring-regular",
"gxTimeBasedUsageMonitoring-regular",
"gxTimeBasedUsageMonitoringHA-regular",
"gxRuleLevelTimeUsageMonitoring-regular",
"gxUsageMonitoringGeoRed-regular",
"gxRuleLevelUsageMonitoringGeoRed-regular"
);
our @charging = (
"chargingAll-medium",
"lteBasicOnlineCharging-regular",
"pdnLevelOnlineCharging-regular",
"lteBasicOnlineOfflineChaStaticPol-regular",
"ggsnBasicOnlineOfflineChaDynamicPol-regular",
"onlineChargingDccaVersion2-regular ",
"lteBasicOnline2-regular "
);
our @ocfuiredirect = (
"ggsnFUIRedirectDPI-regular",
"ggsnFUIRedirectStaticPol-regular",
"lteFUIRedirectDPI-regular",
"redirectOnlineChargingDPI-regular",
"cuRedirectOnlineCharging-regular",
"nonFPTRedirect-regular"
);
our @ocfuiterm = (
"lteFUITerminate-regular",
"lteFUITerminateStaticPol-regular",
"ggsnFUITerminate-regular",
"ggsnFUITerminateStaticPol-regular",
"cuTerminateOnlineCharging-regular"
);
our @home = (
"mgHomeAgentCallFlows-regular",
"mgHaRadiusAuthScenarios-regular",
"mgHomeAgentOnlineCharging-regular"
);
our @epdg = (
"mgEpdgAll-medium",
"ePdgICRCallFlows-regular",
"ePdgWithoutICR-regular",
"ePdgDnsWithoutICR-regular",
"mgSwmWithoutICR-regular",
"ePdgRfChargingProfile-regular",
"ePdgRfTriggers-regular",
"ePdgRfMultiPdn-regular",
"ePdgGaChargingProfile-regular",
"ePdgGaTriggers-regular",
"ePdgGaMultiPdn-regular"
);
our @twag = (
"mgTwagAll--medium", 
"twagOpenSSIDBasicCallFlows--medium" 
);
our @dslBonding = (
"lteDslBondingCallFlows-regular",
"lteDslBondingComboGw-regular",
"lteDslBondingPolicy-regular",
"lteDslBondingPolicySCCG-regular",
"lteChargingDslBonding-regular",
"lteSccgChargingDslBonding-regular"
);
our @sponsorData = (
"pgwGaSponsoredConn-regular",
"pgwGaStaticSponsoredConnHA-regular",
"pgwGaAttachDetachICRsponConn-regular",
"pgwGaAttachDetachICRsponConnOffline-regular"
);
our @pco = (
"ggsnPco-extensive",
"ltePCOSgwPgw-extensive",
"configurableGtpv2ExclPCO-regular"
);
our @custom = ();
our @runtest = ();
our $testflag = 0;
my $printOnly = 0;
sub scheduleRegress
{
my $pkg = $main::package;
if( $main::dflag) {printf("Input Package is $pkg\n");}
if( $printOnly == 0 ) {
printf("Available testbeds $testBeds::tcount\n");
}
if( $pkg =~ /,/ ) {
$pkg =~ s/\s+//g;  
my @values = split(',', $pkg);
my $num = $#values + 1;
printf("Num of packages to regress $num\n");
for my $cnt (0 .. $#values ) {
printf("\n\tRegress Package: $values[$cnt]\n"); 
do_schedule($values[$cnt]);
}
} else {
printf("\n\tRegress Package: $pkg\n"); 
do_schedule($pkg);
}
}
sub do_schedule
{
my $pkg = shift;
if( $pkg eq "express" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@express);
} else {
$multiRun = 1;
doit(@express);
$multiRun = 0;
}
return;
}
if( $pkg eq "quickonly" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@quickonly);
} else {
$multiRun = 1;
doit(@quickonly);
$multiRun = 0;
}
return;
}
if( $pkg eq "quick" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@quick);
} else {
$multiRun = 1;
doit(@quick);
$multiRun = 0;
}
return;
}
if( $pkg eq "basic" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@basic);
} else {
$multiRun = 1;
doit(@basic);
$multiRun = 0;
}
return;
}
if( $pkg eq "basic1" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@basic1);
} else {
$multiRun = 1;
doit(@basic1);
$multiRun = 0;
}
return;
}
if( $pkg eq "vfpbasic" ) { 
if( $main::testTeam == 1 ) {
doitTestTeam(@vfpBasic);
} else {
$vfp = 1;
doit(@vfpBasic);
$vfp = 0;
}
return;
}
if( $pkg eq "general" ) { 
doit(@general);
return;
}
if( $pkg eq "ggsn" ) { 
doit(@ggsn);
return;
}
if( $pkg eq "pmip" ) { 
doit(@pmip);
return;
}
if( $pkg eq "combo" ) { 
doit(@combo);
return;
}
if( $pkg eq "ubreq" ) { 
doit(@ubreq);
return;
}
if( $pkg eq "dbreq" ) { 
doit(@dbreq);
return;
}
if( $pkg eq "spgwho" ) { 
doit(@spgwho); 
return;
}
if( $pkg eq "sgwrelo" ) { 
doit(@sgwrelo);
return;
}
if( $pkg eq "mmerelo" ) { 
doit(@mmerelo);
return;
}
if( $pkg eq "paging" ) { 
doit(@paging);
return;
}
if( $pkg eq "idlesesstimeout" ) { 
doit(@idlesesstimeout);
return;
}
if( $pkg eq "s2b" ) { 
doit(@s2b);
return;
}
if( $pkg eq "redicr" ) { 
doit(@redicr);
return;
}
if( $pkg eq "irat" ) { 
doit(@irat);
return;
}
if( $pkg eq "li" ) { 
doit(@li);
return;
}
if( $pkg eq "timeofday" ) { 
doit(@timeofday);
return;
}
if( $pkg eq "usage" ) { 
doit(@usage);
return;
}
if( $pkg eq "charging" ) { 
doit(@charging);
return;
}
if( $pkg eq "ocfuiredirect" ) { 
doit(@ocfuiredirect);
return;
}
if( $pkg eq "ocfuiterm" ) { 
doit(@ocfuiterm);
return;
}
if( $pkg eq "home" ) { 
doit(@home);
return;
}
if( $pkg eq "epdg" ) { 
doit(@epdg);
return;
}
if( $pkg eq "twag" ) { 
doit(@twag);
return;
}
if( $pkg eq "dslBonding" ) { 
doit(@dslBonding);
return;
}
if( $pkg eq "sponsorData" ) { 
doit(@sponsorData);
return;
}
if( $pkg eq "pco" ) { 
doit(@pco);
return;
}
if( $pkg eq "custom" ) { 
doit(@custom);
return;
}
if( $pkg eq "runtest" ) { 
doit(@runtest);
return;
}
printf("Unknown package $pkg\n");
}
my $testbed = "";
sub doit
{
my @array = @_;
my $numsuites = scalar(@array);
my $dir = cwd();
my $strs = "";
my $str = "";
my $comboTest = "";
if( $testflag == 1 ) {
$strs = "Tests";
$str = "Test";
} else {
$strs = "Suites";
$str = "Suite";
}
printf("\t\tNum of $strs to regress $numsuites\n");
for my $cnt (0 .. $#array) {
my @values = ();
my $suite = "";
my $runlevel = "";
my $regress = "regress";
@values = split('-', $array[$cnt]);
$suite = @values[0]; 
$runlevel = @values[1]; #get runlevel
if( $runlevel eq "" ) {
$runlevel = "regular";
}
if( $printOnly ) {
my $num = $cnt + 1;
printf("\t\t$num: $str: $suite\trunLevel: $runlevel\n");
} else {
if( $testBeds::select ) {
printf("\n\t\tSelect Testbed for $str: $suite Runlevel $runlevel");
$testbed = testBeds::selectTestBed("ANY");
unless( $testbed ) {
printf("\t\tAuto assign testbed . . .\n");
$testbed = testBeds::getTestBed("ANY");
}
} 
chdir($main::root);
if( $multiRun == 1 ) {
if( $testBeds::select ) {
runRegressCmd($suite, $runlevel, $testbed, "run$str");
} else {
if( testBeds::isVmAllowed() ) {
$testbed = testBeds::getTestBed("VM");
runRegressCmd($suite, $runlevel, $testbed, "run$str");
}
if( testBeds::isSimAllowed() ) {
$testbed = testBeds::getTestBed("SIM");
runRegressCmd($suite, $runlevel, $testbed, "run$str");
}
if( testBeds::isHwAllowed() ) {
$testbed = testBeds::getTestBed("HW");
runRegressCmd($suite, $runlevel, $testbed, "run$str");
}
}
} else {
unless( $testBeds::select ) {
if( $vfp == 1 ) {
$testbed = testBeds::getTestBed("VM");
} else {
$testbed = testBeds::getTestBed("ANY");
}
}
my $rc = runRegressCmd($suite, $runlevel, $testbed, "run$str");
if( $rc != 0 ) {
$cnt = $cnt - 1;
}
}
}
}
chdir($dir);
}
sub doitTestTeam
{
my @array = @_;
my $numsuites = scalar(@array);
my $strs = "Suites";
my $str = "Suite";
printf("\t\tNum of $strs to regress $numsuites\n");
for my $cnt (0 .. $#array) {
my @values = ();
my $suite = "";
my $runlevel = "";
@values = split('-', $array[$cnt]);
$suite = @values[0]; 
$runlevel = @values[1]; #get runlevel
if( $printOnly ) {
printf("\t$str: $suite Runlevel $runlevel\n");
} else {
$testbed = testBeds::getTestBed("VM");
$main::subTopology = "";
runRegressCmd($suite, $runlevel, $testbed, "run$str");
$testbed = testBeds::getTestBed("VM");
$main::subTopology = "ismMgB";
runRegressCmd($suite, $runlevel, $testbed, "run$str");
$testbed = testBeds::getTestBed("SIM");
$main::subTopology = "";
runRegressCmd($suite, $runlevel, $testbed, "run$str");
$testbed = testBeds::getTestBed("SIM");
$main::subTopology = "ismMgB";
runRegressCmd($suite, $runlevel, $testbed, "run$str");
$main::subTopology = "";
runRegressCmd($suite, $runlevel, "mvltetb3", "run$str");
$main::subTopology = "ismMgB";
runRegressCmd($suite, $runlevel, "mvltetb4", "run$str");
}
if ($numsuites > 1 ) {
testBeds::findTestBeds();
}
}
}
sub runRegressCmd
{
my $suite = shift;
my $runlevel = shift;
my $testbed = shift;
my $run = shift;
if( $testbed eq "" ) {
printf("Invalid Testbed [$testbed]\n");
return(-1);
}
my $regress = "regress";
if( $main::testTeam == 1 ) {
$regress = "$main::root/regress";
}
my $cmd = "";
if( $suite eq "express" ) {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -reason \"$main::reason\" ";
if( $main::testTeam == 1 ) { 
$main::smgrTest = 0;
$main::Racctest = 0;
} else {
if( $main::subTopology eq "" ) { 
$main::smgrTest = 0;
$main::acctTest = 0;
}
}
if( $main::smgrTest ) {
$cmd .= "-smgrRunExpress true ";
}
if( $main::acctTest ) {
$cmd .= "-acctRunExpress true ";
}
} elsif( $suite eq "priority" ) {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -reason \"$main::reason\" ";
if( $main::startPriority ) {
$cmd .= "-startPriority $main::startPriority ";
} else {
die("-startPriority is $main::startPriority - error\n");
}
if( $main::endPriority ) {
$cmd .= "-endPriority $main::endPriority ";
} else {
die("-endPriority is $main::endPriority - error\n");
}
} else {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -$run $suite -reason \"$main::reason\" ";
}
if( $suite eq "chargingAll" ) {
$cmd .= "-subTopology mgScalingV2 ";
} elsif( $vfp == 1 ) {
$cmd .= "-subTopology vfp ";
} elsif( $suite =~ /twag/ ) {
$cmd .= "-subTopology plasmaMgV3 ";
} else {
if( $main::subTopology ne "" ) { 
$cmd .= "-subTopology $main::subTopology ";
}
}
if( $main::testTeam == 1 || main::globalRoot() ) { 
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest/ ";
if( $main::customGash ne "" ) { 
$cmd .= "-customGash $main::customGash "; 
}
$cmd .= "-emailMode result ";
} else {
if($main::latest == 1 ) {
if($main::ptrCheck == 1 ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest_p/ ";
} else {
if( $main::release eq "0.0" ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest/ ";
} else {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest_s/ ";
}
}
}
if($main::current == 1 ) {
if($main::ptrCheck == 1 ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/ptr-current/ ";
} else {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/current/ ";
}
}
if($main::current == 1 ) {
}
$cmd .= "-nobuild ";
}
if( $main::regressDbg == 1 ) { 
$cmd .= "-debugOnFailure tkcon -exitOnFailure true ";
}
if( $main::addargs ) {
$cmd .= "$main::addargs ";
}
#$cmd .= "> /dev/null 2>&1";
$cmd .= "> $rfile 2>&1";
if($main::dflag) { printf("$cmd\n"); }
printf("\t\tScheduling $suite @ $testbed Level $runlevel ..");
if( $main::dryOnly ) {
printf(".. Dry\n");            
return(0);
} else {
system( $cmd );
if( -e $rfile ) {
my $status = `cat $rfile | grep "Regression test submitted"`;
if ($status) {
printf(".. Done\n");
unlink($rfile);
return(0);
} else {
printf(".. Failed\n");
#if( $main::dflag ) {
printf("Regress Output:\n");
system("cat $rfile");
#}
unlink($rfile);
return(-1);
}
}
}
}
sub dumpPackages
{
my $num = 1;
printf("\tNum\tPackage Desc.\t\tCode\n");
printf("\t--------------------------------------------------\n");
printf("\t$num\tExpress\t\t\texpress\n"); $num++;
printf("\t$num\tQuick Only\t\tquickonly\n"); $num++;
printf("\t$num\tQuick\t\t\tquick\n"); $num++;
printf("\t$num\tBasic\t\t\tbasic (express & quick)\n"); $num++;
printf("\t$num\tBasic1\t\t\tbasic1 (Split express & quick)\n"); $num++;
printf("\t$num\tvfpBasic\t\tvfpbasic\n"); $num++;
printf("\t$num\tGeneral\t\t\tgeneral\n"); $num++;
printf("\t$num\tGGSN\t\t\tggsn\n"); $num++;
printf("\t$num\tPMIP\t\t\tpmip\n"); $num++;
printf("\t$num\tCombo\t\t\tcombo\n"); $num++;
printf("\t$num\tUpdate Brearer\t\tubreq\n"); $num++;
printf("\t$num\tDelete Brearer\t\tdbreq\n"); $num++;
printf("\t$num\tSGW/PGW Handovers\tspgwho\n");  $num++;
printf("\t$num\tSGW Relocation\t\tsgwrelo\n"); $num++;
printf("\t$num\tMME Relocation \t\tmmerelo \n"); $num++;
printf("\t$num\tPaging\t\t\tpaging\n"); $num++;
printf("\t$num\tIdle Session Timeout\tidlesesstimeout\n"); $num++;
printf("\t$num\tS2b\t\t\ts2b\n"); $num++;
printf("\t$num\tRed/ICR\t\t\tredicr\n"); $num++;
printf("\t$num\tIRAT No EHRPD/LTE HO\tirat\n"); $num++;
printf("\t$num\tLI\t\t\tli\n"); $num++;
printf("\t$num\tTime of Day\t\ttimeofday\n"); $num++;
printf("\t$num\tUsage Monitoring\tusage\n"); $num++;
printf("\t$num\tCharging (general)\tcharging\n"); $num++;
printf("\t$num\tOC - FUI Redirect\tocfuiredirect\n"); $num++;
printf("\t$num\tOC - FUI Terminate\tocfuiterm\n"); $num++;
printf("\t$num\tHome Agent\t\thome\n"); $num++;
printf("\t$num\tePDG\t\t\tepdg\n"); $num++;
printf("\t$num\tTWAG\t\t\ttwag\n"); $num++;
printf("\t$num\tPCO\t\t\tpco\n"); $num++;
printf("\t$num\tSponsor Data\t\tsponsorData\n"); $num++;
printf("\t$num\tDsl Bonding\t\tdslBonding\n"); $num++;
printf("\t--------------------------------------------------\n");
}
sub dumpPkgDetails
{
if( $main::package eq "" ) {
printf("Package code missing, please provide from below:\n");
dumpPackages();
return;
}
printf("Package $main::package:\n");
$printOnly = 1;
scheduleRegress();
}
1;
package main;
my $version="v31.1";
use strict;
use Cwd;
our $dflag = 0;
our $dryOnly = 0;   
our $showtb = 0;    
our $noping = 1;    
our $vmonly = 0;    
our $allowhw = 0;   
our $hwonly = 0;    
our $simonly = 0;   
our $smgrTest = 0;  
our $acctTest = 0;  
our $latest = 0;    
our $current = 0;    
our $ptrCheck = 0;    
our $subTopology = "ismMgB";    
our $regressDbg = 0;    
our $startPriority = 0;    
our $endPriority = 0;    
our $addargs = "";
our $user = "";     
our $root = "";     
our $site = "";     
our $server = "";   
our $login = "";    
our $passwd = "";   
our $package = "";  
our $reason = "";
our $testTeam = 0;
our $customGash = "";
our $release = "0.0";
parseArgs();
unless( $package ) {
unless( $showtb ) {
printf("Nothing to run\n"); 
printf("For help, Enter: $0 -h\n");
exit;
}
}
$user = `whoami`;
chomp($user);
unless ($root ) {
getRoot();
}
getSite();
getCvsTag();
regressParams::getRegressParams();
testBeds::readBlacklist();
testBeds::findTestBeds();
unless ($reason) {
$reason = "$root :$version";
}
runSuite::scheduleRegress();
exit;
sub getRoot
{
my $dir = cwd();
chomp($dir);
if( $dir =~ /panos/ ) {
if( $dir =~ /panos\// ) {
$dir =~ /(.*)\/panos\/(.*)/;
$root = "$1/panos/";
} else {
$root = $dir;
}
if( $dflag ) {printf("WS: $root\n");}
return;
}
my @dirs = `find -O3 /home/$user -type d -name \"panos\" -print -prune`;
unless(@dirs) {
my $rc = `ls -la /usr/global/bin 2>/dev/null`;
if( $rc ) {
$root = "/usr/global/bin";
return;
}
}
my $index = 1;
if( $dir =~ /panos/ ) {
for my $choice (@dirs) {
chomp($dirs[$index - 1]);
if( $dflag ) {printf("Comparing $dir and $dirs[$index - 1]\n");}
if( $dirs[$index - 1] =~ /$dir/ ) {
$root = $dirs[$index - 1];
if( $dflag ) {printf("WS: $root\n");}
return;
} 
$index++;
}
}
$index = 1;
for my $choice (@dirs) {
chomp($dirs[$index - 1]);
printf("$index) $dirs[$index - 1]\n");
$index++;
}
print "Enter your ($user) ws choice: ";
my $choice = <STDIN>;
chomp($choice);
unless( $choice > 0 && $choice < $index ) {
die("Invalid input $choice - please try again\n");
}
$root = $dirs[$choice - 1];
chomp($root);
if( $dflag ) {printf("WS: $root\n");}
}
sub getSite
{
unless( $site eq "" ) {
printf("Location: $site\t");
return;
}
my $cmd = "/usr/local/timostools/usertosite.sh $user 2>/dev/null";
my $output = `$cmd`;
chomp($output);
unless( $output ) {
if( globalRoot() ) {
return;
}
die("Unable to get location for $user\n");
}
setServers($output);
printf("Location: $output\t");
}
sub globalRoot
{
if( $root eq "/usr/global/bin" ) {
return(1);
} 
return(0);
}
sub setServers
{
my $output = shift;
if( $output eq "MtnView" ) {
$site = "mvlte";
$server = "alphatest.mv.usa.alcatel.com";
$login = "alphatest";
$passwd = "tigris";
}
if( $output eq "Bratislava" ) {
$site = "ba";
$server = "baltehwrtb01.lab.sk.alcatel-lucent.com";
if( testBeds::_isAlive($server) ) {
$login = "baltehwrtb01";
} else {
printf("$server down - trying again\n"); 
$server = "baltehwrtb02.lab.sk.alcatel-lucent.com";
if( testBeds::_isAlive($server) ) {
$login = "baltehwrtb02";
} else {
die("Can not get Test Bed status - $server down\n"); 
}
}
$passwd = "tigris";
}
if( $output eq "Naperville" ) {
$site = "npv";
$server = "npvgui.ih.lucent.com";
$login = "npvgui";
$passwd = "tigris";
}
}
sub getCvsTag
{
my $cvsfile = "$main::root/CVS/Tag";
my $lab = "";
my $fd = new IO::File;
unless( open($fd, "< $cvsfile") ){
if($dflag){printf("Unable to open $cvsfile\n");}
return(-1);
}
my $data = <$fd>;
close($fd);
chomp($data);
$data =~ s/TTiMOS-MG_//g;
$data =~ s/_current//g;
$release = $data;
$release =~ s/_/./g;
printf("Release: $release\n");
}
sub parseArgs
{
my @T = @ARGV;
my $argTest = 0;
if ( scalar @T == 0 ) {
printf("Must supply one or more parameters\n"); 
printf("For more help, Enter: $0 -h\n");
exit(0);
}
while( my $a = shift(@T) ) {
if ( $a eq "-h" ) {
help();
exit(0);
}
if ( $a eq "-v" ) {
printf("VERSION: $version\n");
exit(0);
}
if ( $a eq "-d" ) {
$dflag = 1;
next;
}
if ( $a eq "-dry" ) {
$dryOnly = 1;
next;
}
if ( $a eq "-showtb" ) {
$showtb = 1;
next;
}
if ( $a eq "-suite" ) {
my $iput = shift(@T);
if($dflag) { printf("Input: [$iput]\n"); }
if( $iput =~ /,/ ) {
$iput =~ s/\s+//g;  
my @values = split(',', $iput);
for my $cnt (0 .. $#values ) {
if($dflag) { printf("Suite-RunLevel: $values[$cnt]\n"); }
push(@runSuite::custom, $values[$cnt]);
}
} else {
if($dflag) { printf("Suite-RunLevel: $iput\n"); }
push(@runSuite::custom, $iput);
}
$package = "custom";
next;
}
if ( $a eq "-runTest" ) {
my $iput = shift(@T);
my %comboTest = ();
if($dflag) { printf("Input: [$iput]\n"); }
if( $iput =~ /,/ ) {
$iput =~ s/\s+//g;  
my @values = split(',', $iput);
for my $cnt (0 .. $#values ) {
my $testRun = $values[$cnt];
if($dflag) { printf("Test-RunLevel: $testRun\n"); }
my @tmp = split('-', $testRun);
my $test = $tmp[0];
my $runLvl = $tmp[1];
if( $runLvl eq "" ) {
$runLvl = "regular";
}
#printf("$test $runLvl - ");
unless( $comboTest{$runLvl} ) { 
$comboTest{$runLvl} = $test;
} else {
$comboTest{$runLvl} = $comboTest{$runLvl}." $test";
}
#printf(" $comboTest{$runLvl}\n");
}
foreach my $key (keys %comboTest ) {
push(@runSuite::runtest, "$comboTest{$key}-$key");
#printf("Adding $comboTest{$key}-$key\n");
}
} else {
if($dflag) { printf("test-RunLevel: $iput\n"); }
push(@runSuite::runtest, $iput);
}
$package = "runtest";
$runSuite::testflag = 1;
next;
}
if ( $a eq "-pkg" ) {
$package = shift(@T);
next;
}
if ( $a eq "-st" ) {
$testBeds::select = 1;
next;
}
if ( $a eq "-reason" || $a eq "-title" ) {
$reason = shift(@T);
$reason = $reason." :$version";
next;
}
if ( $a eq "-vm" ) {
$vmonly = 1;
next;
}
if ( $a eq "-hw" ) {
$hwonly = 1;
$allowhw = 1;
next;
}
if ( $a eq "-sim" ) {
$simonly = 1;
next;
}
if ( $a eq "-ping" ) {
$noping = 0;
next;
}
if ( $a eq "-smgr" ) {
$smgrTest = 1;
next;
}
if ( $a eq "-acct" ) {
$acctTest = 1;
next;
}
if ( $a eq "-latest" ) {
$latest = 1;
next;
}
if ( $a eq "-current" ) {
$current = 1;
next;
}
if ( $a eq "-start" ) {
$startPriority = shift(@T);
next;
}
if ( $a eq "-end" ) {
$endPriority = shift(@T);
push(@runSuite::custom, "priority");
$package = "custom";
next;
}
if ( $a eq "-ptr" ) {
$ptrCheck = 1;
next;
}
if ( $a eq "-addargs" ) {
$addargs = shift(@T);
next;
}
if ( $a eq "-showpkg" ) {
$package = shift(@T);
runSuite::dumpPkgDetails();
exit;
}
if ( $a eq "-panos" || $a eq "-root" || $a eq "-ws" ) {
$root = shift(@T);
next;
}
if ( $a eq "-v1" ) {
$subTopology = "";
next;
}
if ( $a eq "-site" ) {
$site = shift(@T);
if( $site eq "mv" ) {
setServers("MtnView");
} elsif ($site eq "ba") {
setServers("Bratislava");
} elsif ($site eq "npv") {
setServers("Naperville");
} else {
die("Incorrect site mentiond (mv, npv, ba allowed)");
}
next;
}
if ( $a eq "-v2" ) {
$subTopology = "ismMgB";
next;
}
if ( $a eq "-v3" ) {
$subTopology = "ismMgV3";
next;
}
if ( $a eq "-plasma" ) {
$subTopology = "plasmaMgV3";
next;
}
if ( $a eq "-vfp" ) {
$subTopology = "vfp";
$runSuite::vfp = 1;
next;
}
if ( $a eq "-regressDbg" ) {
$regressDbg = 1;
next;
}
if ( $a eq "-test" ) {
$testTeam = 1;
$root = "/usr/global/bin";
next;
}
if ( $a eq "-customGash" ) {
$customGash = shift(@T);
next;
}
if ( $a eq "-rel" ) {
$release = shift(@T);
next;
}
die("Unknown Command Line Option: '$a'\n");
}
}
sub help
{
printf("Following parameters are supported:\n");
printf("\t-root <ws>: Provide workspace or you will be asked if not already in ws\n");
printf("\t-site <site>: Provide mv / ba / npv for MtnView, Bratislava or Naperville sites\n");
printf("\t-pkg <code>: Provide pkg code to run regressions\n");
printf("\t-suite <suite-runLevel>: Provide suite name and runlevel\n");
printf("\t-runTest <test>: Provide test name and runlevel\n");
printf("\t-reason <reason>: Provide reason to run regressions (optional default takes WS)\n");
printf("\t-addargs <args>: Provide additional regress arguments besides already supported\n");
printf("\t-smgr: Run express with SMGR test infra on (Default on)\n");
printf("\t-acct: Run express with ACCT test infra on (Default on)\n");
printf("\t-latest: Run package with latest image instead of local panos\n");
printf("\t-current: Run package with current image instead of local panos\n");
printf("\t-ptr: Run package with latest or current ptrCheck image instead of local panos\n");
printf("\t-start: Specify startPriority instead of suite/test\n");
printf("\t-end: Specify endPriority instead of suite/test\n");
printf("\t-regressDbg: Debug regress run - stop on error\n");
printf("\t-v1: Do not use subTopology option\n");
printf("\t-v2: Use subTopology ismMgB (Default)\n");
printf("\t-v3: Use subTopology ismMgV3\n");
printf("\t-vfp: Use subTopology vfp\n");
printf("\t-vm : If used, only VM testbeds will used\n");
printf("\t-hw : If used, only HW testbeds will used\n");
printf("\t-sim : If used, only SIM testbeds will used\n");
printf("\t-ping : If used, ping testbeds before selection\n");
printf("\t-st : Select a testbed instead of random pickup of one\n");
printf("\n\t-test: For test team use (express, quick or basic only)\n");
printf("\t-customGash <tag>: For test team if they need custom gash\n");
printf("\t-rel <release>: For test team if they need specific release images default 0.0\n");
printf("\n\t-dry: Dry run - just shows regress commands\n");
printf("\t-showpkg <code>: Show suites and levels in a pkg code\n");
printf("\t-showtb : Show available testbeds only\n");
printf("\t-v: Dumps the version\n");
printf("\t-d: turn on debug\n");
printf("\t-h: This help menu\n");
printf("\nSupported Packages and their codes:\n");
runSuite::dumpPackages();
printf("\nExample 1:\n");
printf("\tTo run express and quick:\n\t$0 -pkg basic\n");
printf("\nExample 2:\n");
printf("\tWith reason:\n\t$0 -pkg basic -reason \"DTSxxxx\"\n");
printf("\nExample 3:\n");
printf("\tRun multiple packages:\n\t$0 -pkg basic,combo -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -pkg \"basic, combo\" -reason \"DTSxxxx\"\n");
printf("\nExample 4:\n");
printf("\tRun using Custom Suite:\n\t$0 -suite mgQuick-quickOnly -reason \"DTSxxxx\"\n");
printf("\nExample 5:\n");
printf("\tRun multiple Custom Suite:\n\t$0 -suite mgQuick-quickOnly,lteCallFlows-regular -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -suite \"mgQuick-quickOnly, lteCallFlows-regular\" -reason \"DTSxxxx\"\n");
printf("\nExample 6:\n");
printf("\tRun using Custom Test:\n\t$0 -runTest dedBrQciArpChTests_P0-regular -reason \"DTSxxxx\"\n");
printf("\nExample 7:\n");
printf("\tRun multiple Custom Tests:\n\t$0 -runTest dedBrQciArpChTests_P0-regular,dedBrQciArpChTests_P1-regular -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -suite \"dedBrQciArpChTests_P0, dedBrQciArpChTests_P1\" -reason \"DTSxxxx\"\n");
printf("\nExample 8:\n");
printf("\tTo run express and quick using specific workspace:\n\t$0 -pkg basic -root /home/xxx/00/panos\n");
printf("\nExample 9:\n");
printf("\tShow detail contents of a package:\n\t$0 -showpkg basic\n");
}
