#!/usr/bin/perl
#**************************************************************************
#   This file was generated from a tool and
#   is subject to change.  Do not edit this file
#   directly, if you want to maintain any changes.
# 
#   Author: Amod Deshpande
# 
#   Copyright (c) 2014-2016 Alcatel-Lucent, 2016 Nokia
# 
# $Id: Exp $
#**************************************************************************
package regressParams;
use strict;
use lib '/usr/local/timostools/perllib';
use IO::File;
use File::Path;
use File::Basename;
use Net::Telnet;
use Time::Local;
use Cwd;
our %regressParams = ();
sub getRegressParams
{
my $lab = "";
my $rpfile = getRegressParamsLocation();
printf("Reading testbed params ....\n");
my $fd = new IO::File;
unless( open($fd, "< $rpfile") ){
die("Unable to open $rpfile\n");
}
my @data = <$fd>;
close($fd);
shift(@data);
foreach my $line (@data) {
chomp($line);
unless( $line =~ /^mvlte/ 
|| $line =~ /^npv/ 
|| $line =~ /^ba/ 
|| $line =~ /^ath/ 
|| $line =~ /^es/
) {
next;
}
unless( $line =~ /SITE/ 
|| $line =~ /ACCESS/ 
|| $line =~ /DESCRIPTION/
|| $line =~ /ALLOW_RUNLEVELS/
|| $line =~ /SUBTOPO/ 
|| $line =~ /DENY_SUBTOPOS/ 
) {
next;
}
if( $main::dflag) { printf("Working on: $line\n"); }
my $origline = $line;
$line =~ s/\s+/\;/g;    
my @values = split(';', $line);
$lab = $values[0];
if( $lab =~ /scale/
|| $lab =~ /gash/ 
|| $lab =~ /cli/ 
|| $lab =~ /endur/ ) {
next;
}
if( $main::dflag) { printf("Working on: $lab\n"); }
if( $line =~ /;SITE;/ ) {
$regressParams{$lab}{'lab'} = $lab;
$regressParams{$lab}{'type'} = "ANY"; 
$regressParams{$lab}{'allowed'} = 1;    
$regressParams{$lab}{'topology'} = "ANY"; 
$regressParams{$lab}{'deny'} = "ANY"; 
next;
}
if( $line =~ /;DESCRIPTION;/ ) {
if ( $origline =~ /(do[\s_-]*not[\s_-]*use|reservi?ed)/i ) {
$regressParams{$lab}{'allowed'} = 0;
next;
}
if( $line =~ /Hardware/ ) {
$regressParams{$lab}{'type'} = "HW";
next;
}
if( $line =~ /VM;Support/ || $line =~ /VM;support/) {
$regressParams{$lab}{'type'} = "VM";
next;
}
if( $line =~ /SimPC/ ) {
$regressParams{$lab}{'type'} = "SIM";
next;
}
$regressParams{$lab}{'type'} = "UNK";
}
if( $line =~ /;SUBTOPO;/ ) {
$regressParams{$lab}{'topology'} = $values[2];
next;
}
if( $line =~ /;DENY_SUBTOPOS;/ ) {
my $deny = $line;
$deny =~ s/$lab//g;     
$deny =~ s/;DENY_SUBTOPOS;//g;
$regressParams{$lab}{'deny'} = $deny;
next;
}
if( $line =~ /;ALLOW_RUNLEVELS;/ ) {
$regressParams{$lab}{'allowed'} = 0;
next;
}
if( $line =~ /;ACCESS;/ && $line =~ /private/) {
$regressParams{$lab}{'allowed'} = 0;
next;
}
}
if( $main::dflag) {
dumpRegressParams();
}
}
sub getRegressParamsLocation
{
my $rpext = "regress.params";
if( main::globalRoot() ) {
my $rpfile = "$main::root/$rpext";
if( -e $rpfile ) {
return($rpfile);
}
}
my $timosRegress = `echo "\${HOME:-/tmp/\$USER}/.regress/$rpext"`;
chomp($timosRegress);
unless (-e $timosRegress) {
`regress > /dev/null 2>&1`;
}
if( -e $timosRegress ) {
my $now = time;
my $sec = (localtime($now))[0];
my $min = (localtime($now))[1];
my $hrs = (localtime($now))[2];
my $day = (localtime($now))[3];
my $month = (localtime($now))[4] + 1;
my $year = (localtime($now))[5] + 1900;
my $month2 = $month - 1;
my $begin_sec = timelocal($sec, $min, $hrs, $day, $month2, $year);
my $regress_sec = (stat($timosRegress))[9];
if($main::dflag){printf("$sec $min $hrs $day $month $year $begin_sec $regress_sec\n")};
my $days = 7;
if( $begin_sec - $regress_sec > ($days*24*3600) ) {
printf("\nNeed to update $timosRegress\n");
system("make timostools");
}
return($timosRegress);
}
die("regress.params ($timosRegress) not found\n");
}
sub dumpRegressParams
{
my $count = 0;
foreach my $lab (keys %regressParams) {
printf("%d: $regressParams{$lab}{'lab'} : $regressParams{$lab}{'type'} : $regressParams{$lab}{'topology'} : $regressParams{$lab}{'deny'} : $regressParams{$lab}{'allowed'}\n", $count++);
}
}
sub getRegressionStatus
{
my $tbfile = shift;
my $state = shift;
my @lines = ();
if( main::globalRoot() ) {
@lines = `ls /usr/global/regression/$state`;
} else {
my $t = new Net::Telnet ( Errmode => 'return' );
$t->open($main::server);
if($t->errmsg ) {
my $errmsg = $t->errmsg;
die("Error: $errmsg \n");
} 
$t->login($main::login, $main::passwd);
@lines = $t->cmd("ls /usr/global/regression/$state");
}
my $fd = new IO::File;
unless( open($fd, "> $tbfile") ){
die("Unable to open $tbfile to write\n");
}
print $fd "@lines";
if($main::dflag){printf("$state:\n");print "@lines"; printf("\n");}
close $fd;
}
1;
package testBeds;
use strict;
use IO::File;
use File::Path;
use File::Basename;
use Cwd;
our @vmtestbed = ();
our @hwtestbed = ();
our @simtestbed = ();
our $select = 0;     
our $noselect = 0;   
our $allowAllTb = 0; 
our $tcount = 0;
our $vmtcount = 0;
our $hwtcount = 0;
our $simtcount = 0;
our $vmstatus = "";
our $hwstatus = "";
our $simstatus = "";
my $tbfile = "/tmp/testbed$$.status";
my $blacklist = "blacklistTB.txt";
my $osName=`/bin/uname -s`;
chomp($osName);
my $vmidle = 0;
my $hwidle = 0;
my $simidle = 0;
sub findTestBeds
{
if( $main::dflag) {printf("My OS is $osName\n");}
printf("Finding idle testbeds....\n");
if( isVmAllowed() ) {
doit("idle", "VM");
if($vmtcount == 0 ) {
printf("No idle VM testbeds available - looking for inprogress VM\n");
doit("inprogress", "VM");
} else {
$vmidle = 1;    
}
}
if( isHwAllowed() ) {
doit("idle", "HW");
if($hwtcount == 0 ) {
printf("No idle HW testbeds available - looking for inprogress HW\n");
doit("inprogress", "HW");
} else {
$hwidle = 1;    
}
}
if( isSimAllowed() ) {
doit("idle", "SIM");
if($simtcount == 0 ) {
printf("No idle SIM testbeds available - looking for inprogress SIM\n");
doit("inprogress", "SIM");
} else {
$simidle = 1;   
}
}
$tcount = $vmtcount + $hwtcount + $simtcount;
if($tcount == 0 ) {
die("No testbeds are idle or inprogress - please check later\n");
} 
my @a = sort tbSort @vmtestbed;
@vmtestbed = @a;
my @a = sort tbSort @hwtestbed;
@hwtestbed = @a;
my @a = sort tbSort @simtestbed;
@simtestbed = @a;
if( $main::showtb ) {
my $index = 1;
if( isVmAllowed() ) {
printf("\n\n\t\tVM Testbeds ($vmstatus):\n\t\t");
for my $i (0 .. $#vmtestbed ) {
printf("%2d) %-15s", $index, $vmtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
}
if( isHwAllowed() ) {
printf("\n\n\t\tHW Testbeds ($hwstatus):\n\t\t");
for my $i (0 .. $#hwtestbed ) {
printf("%2d) %-15s", $index, $hwtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
}
if( isSimAllowed() ) {
printf("\n\n\t\tSIM Testbeds ($simstatus):\n\t\t");
for my $i (0 .. $#simtestbed ) {
printf("%2d) %-15s", $index, $simtestbed[$i]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
}
printf("\n\n");
exit;
}
}
}
sub tbSort
{
if ($a =~ /^$main::site/) { 
return -1; 
} elsif ($b =~ /^$main::site/) { 
return 1; 
} else { 
return $a cmp $b; 
} 
}
sub doit
{
my $status = shift;
my $tbtype = shift;
if( $main::site eq "npv" || $main::site eq "mvlte" ) {
main::setServers("MtnView");
regressParams::getRegressionStatus($tbfile, $status);
_doit($status, $tbtype);
main::setServers("Naperville");
regressParams::getRegressionStatus($tbfile, $status);
_doit($status, $tbtype);
} 
if($main::site eq "ba") {
main::setServers("Bratislava");
regressParams::getRegressionStatus($tbfile, $status);
_doit($status, $tbtype);
}
if($main::site eq "ath") {
main::setServers("Athens");
regressParams::getRegressionStatus($tbfile, $status);
_doit($status, $tbtype);
}
if($main::site eq "es") {
main::setServers("Espoo");
regressParams::getRegressionStatus($tbfile, $status);
_doit($status, $tbtype);
}
}
sub _doit
{
my $status = shift;
my $tbtype = shift;
regressParams::getRegressionStatus($tbfile, $status);
my $fd = new IO::File;
unless( open($fd, "< $tbfile") ){
die("Unable to open $tbfile to read\n");
}
while( <$fd> ) {
chomp($_);
my $line = $_;
if( $line =~ /\[/ ) {
next;
}
$line =~ s/\s+/\;/g;    
if( $main::dflag) { printf("TBED: $line\n");}
my %values = split(';', $line);
foreach my $tbed (%values) {
unless($tbed) {
next;
}
if( $main::dflag) { printf("testbed $tbtype: $tbed  "); }
if( isAllowed($tbed) ) {
if( $tbtype eq "VM" && isVmTb($tbed) && isAlive($tbed) ) {
$vmtestbed[$vmtcount++] = $tbed;
$tbtype = "VM";
$vmstatus = $status;
$vmstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
} 
if ( $tbtype eq "HW" && isHwTb($tbed) && isAlive($tbed) ) {
$hwtestbed[$hwtcount++] = $tbed;
$tbtype = "HW";
$hwstatus = $status;
$hwstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
} 
if ( $tbtype eq "SIM" && isSimTb($tbed) && isAlive($tbed) ) {
$simtestbed[$simtcount++] = $tbed;
$tbtype = "SIM";
$simstatus = $status;
$simstatus =~ s/://g;    
if( $main::dflag) { printf("Included\n"); }
next;
}
if( $main::dflag) { printf("Ignore - VM, HW, SIM check failed\n"); }
next;
}
if( $main::dflag) { printf("Not allowed\n"); }
}
}
close($fd);
unlink($tbfile);
}
sub isVmAllowed
{
if( $main::hwonly == 1 || $main::simonly == 1) {
return(0);
}
return(1);
}
sub isHwAllowed
{
if( $main::vmonly == 1 || $main::simonly == 1 || $main::allowhw == 0 || $runSuite::vfp == 1) {
return(0);
}
return(1);
}
sub isSimAllowed
{
if( $main::hwonly == 1 || $main::vmonly == 1 || $runSuite::vfp == 1) {
return(0);
}
return(1);
}
sub isVmTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "VM" ) {
return(1);
}
return(0);
}
sub isHwTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "HW" ) {
return(1);
}
return(0);
}
sub isSimTb
{
my $host = shift;
if( $regressParams::regressParams{$host}{'type'} eq "SIM" ) {
return(1);
}
return(0);
}
sub isAllowed
{
my $host = shift;
if ( $allowAllTb ) {
return(1);
}
if( $host =~ /scale/
|| $host =~ /gash/ 
|| $host =~ /cli/ 
|| $host =~ /red/ 
|| $host =~ /endur/ ) {
return(0);
}
if( isBlackList( $host ) ) {
return(0);
}
if( $regressParams::regressParams{$host}{'allowed'} == 0 ) {
return(0);
}
if( isHwTb($host) ) {
if( $main::subTopology =~ /$regressParams::regressParams{$host}{'deny'}/ ) {
return(0);
}
if( $main::subTopology eq $regressParams::regressParams{$host}{'topology'} ) {
return(1);
}
if( "ANY" eq $regressParams::regressParams{$host}{'topology'} ) {
return(1);
}
return(0);
}
return(1);
}
sub isAlive
{
my $host = shift;
if( $main::dryOnly || $main::showtb || $main::noping ) {
return(1);
}
my $rc = _isAlive($host);
return($rc);
}
sub _isAlive
{
my $host = shift;
my $fd = "";
if($osName ne "Linux"){
$fd = new IO::File("ping $host -n 2 | grep \"Received = 2\"  2>/dev/null |");
} else {
$fd = new IO::File("/bin/ping -c 2 -W 20 $host | grep \"[12] received\" 2>/dev/null |");
}
unless( $fd ) {
if( $main::dflag) {printf("Ping failed to host: $host\n");}
return(0);
}
my $rc = <$fd>;
chomp($rc);
if ( $rc =~ /[a-z]/i ) {
if( $main::dflag) {printf("Ping success to host: $host\n");}
return(1);
}
return(0);
}
my %blackList = ();
sub readBlacklist
{
my $file = "";
if( -e "/home/$main::user/$blacklist" ) {
$file = "/home/$main::user/$blacklist";
}
if( -e $blacklist ) {
$file = $blacklist;
}
if( -e "$main::root/$blacklist" ) {
$file = "$main::root/$blacklist";
}
if( -e "/tmp/$blacklist" ) {
$file = "/tmp/$blacklist";
}
unless ($file ) {
if( $main::dflag) { printf("No blacklist file\n"); }
return;
}
my @contents = `cat $file 2> /dev/null`;
foreach my $line (@contents) {
chomp($line);
$blackList{$line} = 1;
if( $main::dflag) { printf("$line is blacklist TB\n"); }
}
}
sub isBlackList
{
my $tb = shift;
if( $blackList{$tb} ) {
return 1;
}
return 0;
}
sub selectTestBed
{
my $tbtype = shift;
my $index = 1;
my $cntr = 1;
if( isVmAllowed() && ($tbtype eq "ANY" || $tbtype eq "VM") ) {
printf("\n\n\t\tVM Testbeds ($vmstatus):\n\t\t");
for my $choice (@vmtestbed) {
printf("%2d) %-15s", $index, $vmtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
if( isHwAllowed() && ($tbtype eq "ANY" || $tbtype eq "HW") ) {
$cntr = 1;
printf("\n\n\t\tHW Testbeds ($hwstatus):\n\t\t");
for my $choice (@hwtestbed) {
printf("%2d) %-15s", $index, $hwtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
if( isSimAllowed() && ($tbtype eq "ANY" || $tbtype eq "SIM") ) {
$cntr = 1;
printf("\n\n\t\tSIM Testbeds ($simstatus):\n\t\t");
for my $choice (@simtestbed) {
printf("%2d) %-15s", $index, $simtestbed[$cntr - 1]);
if( $index % 4 == 0 ) { 
printf("\n\t\t");
}
$index++;
$cntr++;
} 
}
print "\n\n\t\tEnter your Testbed choice: ";
my $choice = <STDIN>;
chomp($choice);
unless( $choice > 0 && $choice < $index ) {
printf("\t\tInvalid input $choice - please try later\n");
return("");
}
if( $choice <= $vmtcount ) {
if( $main::dflag) {printf("User selected VM $choice - Returning $vmtestbed[$choice - 1]\n" );}
return($vmtestbed[$choice - 1]);
} 
if( $choice > $vmtcount && $choice <= ($vmtcount + $hwtcount)) {
if( $main::dflag) {printf("User selected HW $choice\n" );}
$choice = $choice - $vmtcount;
if( $main::dflag) {printf("HW Selection: $choice (VM $vmtcount) - Returning $hwtestbed[$choice - 1]\n" );}
return($hwtestbed[$choice - 1]);
} 
if( $main::dflag) {printf("User selected SIM $choice\n" );}
$choice = $choice - $vmtcount - $hwtcount;
if( $main::dflag) {printf("SIM Selection: $choice (VM $vmtcount HW $hwtcount) -  Returning $simtestbed[$choice - 1]\n" );}
return($simtestbed[$choice - 1]);
}
my $lastvm = 0;
my $lasthw = 0;
my $lastsim = 0;
sub getTestBed
{
my $tbtype = shift;
if( $tbtype eq "ANY" ) {
if( ($lastvm + $lasthw + $lastsim) >= $tcount ) {
$lastvm = $lastsim = $lasthw = 0;
}
if( $vmidle == 0 && $hwidle == 0 && $simidle == 0 ) {
unless( $noselect ) {
return( selectTestBed($tbtype) );
}
}
if( $vmtcount && $lastvm <= ($vmtcount-1) ) {
return($vmtestbed[$lastvm++]);
}
if( $simtcount && $lastsim <= ($simtcount-1) ) {
return($simtestbed[$lastsim++]);
}
if( $hwtcount && $lasthw <= ($hwtcount-1) ) {
return($hwtestbed[$lasthw++]);
}
}
if( $tbtype eq "VM" ) {
if( $lastvm >= $vmtcount ) {
$lastvm = 0;
}
if( $vmidle == 0 ) {
unless( $noselect ) {
return( selectTestBed($tbtype) );
}
}
if( $vmtcount && $lastvm <= ($vmtcount-1) ) {
return($vmtestbed[$lastvm++]);
}
}
if( $tbtype eq "HW" ) {
if( $lasthw >= $hwtcount ) {
$lasthw = 0;
}
if( $hwidle == 0 ) {
unless( $noselect ) {
return( selectTestBed($tbtype) );
}
}
if( $hwtcount && $lasthw <= ($hwtcount-1) ) {
return($hwtestbed[$lasthw++]);
}
}
if( $tbtype eq "SIM" ) {
if( $lastsim >= $simtcount ) {
$lastsim = 0;
}
if( $simidle == 0 ) {
unless( $noselect ) {
return( selectTestBed($tbtype) );
}
}
if( $simtcount && $lastsim <= ($simtcount-1) ) {
return($simtestbed[$lastsim++]);
}
}
return ("");
}
1;
package forkMgr;
use strict;
use IO::File;
use File::Basename;
use File::Path;
sub new 
{
my $proto = shift;
my $class = ref($proto) || $proto;
my $self = {};
%{$self->{'pidList'}} = ();
$self->{'max'} = 1;
$self->{'nap'} = .200;
$self->{'mgr'} = $$;
$SIG{CHLD} = 'IGNORE';
$SIG{PIPE} = 'IGNORE';
$|++;
bless $self, $class;
return($self);
}
sub setNap
{
my $self = shift;
my $nap = shift;
if ( $nap == 0 ) {
$nap = .01;
}
$self->{'nap'} = $nap;
}
sub config
{
my $self = shift;
my $max = shift;
$self->{'max'} = $max;
%{$self->{'pidList'}} = ();
$self->{'mgr'} = $$;
}
sub fork
{
my $self = shift;
unless( $self->{'mgr'} == $$ ) {
exit(0);
}
my $pid = fork();
unless( $pid ) {
return($pid);
}
$self->{'pidList'}{$pid} = 1;
return($pid);
}
sub checkPoint
{
my $self = shift;
unless( $self->{'mgr'} == $$ ) {
exit(0);
}
if ( scalar keys %{$self->{'pidList'}} < $self->{'max'} ) {
return(1);
}
while(1) {
select( undef, undef, undef, $self->{'nap'} );
foreach my $pid (keys %{$self->{'pidList'}} ) {
if ( kill( 0, $pid ) ) {
next;
}
delete $self->{'pidList'}{$pid};
}
if ( scalar keys %{$self->{'pidList'}} < $self->{'max'} ) {
last;
}
}
return(1);
}
sub wrapUp
{
my $self = shift;
unless( $self->{'mgr'} == $$ ) {
exit(0);
}
while(1) {
select( undef, undef, undef, $self->{'nap'} );
foreach my $pid (keys %{$self->{'pidList'}}) {
if ( kill( 0, $pid ) ) {
next;
}
delete $self->{'pidList'}{$pid};
}
if ( scalar keys %{$self->{'pidList'}} == 0 ) {
last;
}
}
return(1);
}
1;
package sysInfo;
use strict;
use IO::File;
use File::Basename;
use File::Path;
my $numCPU = 0;
my $defaultCPU = 8;
my $os = "";
sub new 
{
my $proto = shift;
my $class = ref($proto) || $proto;
my $self = {};
unless( $os ) {
my @result = `uname -s`;
chomp(@result);
$os = $result[0];
}
bless $self, $class;
return($self);
}
sub isLinux
{
my $self = shift;
if ( $os =~ /Linux/ ) {
return(1);
}
return(0);
}
sub getCPUcount
{
my $self = shift;
if ( $numCPU > 0 ) {
return($numCPU);
}
if ( $self->isLinux() ) {
my $fd = new IO::File( "cat /proc/cpuinfo | grep processor |" );
if ( $fd ) {
while( <$fd> ) {
$numCPU++;
}
close($fd);
return($numCPU);
}
}
$numCPU = $defaultCPU;
return($numCPU);
}
1;
package runSuite;
use strict;
use Cwd;
our %packages = (
"custom" => {
"suites" => [],
"hidden" => 1,
},
"runtest" => {
"suites" => [],
"hidden" => 1,
},
"express" => {
"description" => "Express",
"suites" => [
"express-express",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
{
"sub" => "ismMgV3",
"phys" => "lteDefault",
},
],
},
"quickonly" => {
"description" => "Quick Only",
"suites" => [
"mgExpress-quick",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
{
"sub" => "ismMgV3",
"phys" => "lteDefault",
},
],
},
"quick" => {
"description" => "Quick",
"suites" => [
"mgQuick-quickOnly",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
{
"sub" => "ismMgV3",
"phys" => "lteDefault",
},
],
},
"basic" => {
"description" => "Basic",
"suites" => [
"express-express",
"mgQuick-quickOnly",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
{
"sub" => "ismMgV3",
"phys" => "lteDefault",
},
],
},
"basic1" => {
"description" => "Basic (separated)",
"suites" => [
"mgExpress-quickOnly",
"mgCli-express",
"mgQuickSgwIcr-quickOnly",
"mmeGracefulRestart-quickOnly",
"gaQuick-quickOnly",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
{
"sub" => "ismMgV3",
"phys" => "lteDefault",
},
],
},
"vfpBasic" => {
"description" => "VFP Basic",
"suites" => [
"express-express",
"mgQuick-quickOnly",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "lteDefault",
},
],
},
"general" => {
"description" => "General",
"suites" => [
"lteCallFlows-medium",
"lteMBCmdSgwPgw-regular",
"ltePathMgmtSgwPgw-regular",
"ltePiggybackSgwPgw-regular",
"gyMidSessionRgChg-regular",
],
},
"ggsn" => {
"description" => "GGSN",
"suites" => [
"ggsnCallFlows-medium",
"ggsnIdleSesTimeout-regular",
"ggsnIdleSesTimeout_GTPv0-regular",
"ggsnRadIdleSesTimeoutMApn-regular"
],
},
"pmip" => {
"description" => "PMIP",
"suites" => [
"pgwPmipS2aCallFlowsLteEhrpdCombo-regular",
"pgwPmipS2aQos-regular",
"pgwPmipS2aCallFlowsHA-regular",
"pmipDedBearers-regular",
"pmipDedBearersHA-regular",
"pmipPgwRf-regular",
"ehrpdPgwTests-medium",
"pgwPmipS2aCallFlows-regular",
"pgwPmipS2aCallFlowInteractions-regular",
],
},
"combo" => {
"description" => "Combo",
"suites" => [
"sccgIratCallFlows-regular",
"sccgIratCallFlowsHA-regular",
"sccgS11CallFlows-regular",
"sccgMiscFeatures-regular",
"sccgS11CallFlowsICR-regular",
"sccgS2aIratCallFlows-regular",
"sccgS11CallFlowsICRWithHA-regular ",
"sccgS11ICRTrafficDetection-regular",
],
},
"ubreq" => {
"description" => "Update Bearer",
"suites" => [
"UpdateBearerSgwPgw-regular",
"lteS4S12nwInit-regular",
],
},
"dbreq" => {
"description" => "Delete Bearer",
"suites" => [
"lteS4S12Vprn-regular",
"createDeleteDedBearersSgwPgw-regular",
],
},
"spgwho" => {
"description" => "SGW/PGW Handovers",
"suites" => [
"handoverSgwPgw-regular",
"s1HandoverSgwPgw-regular",
"s1HandoverV6SgwPgw-regular",
"multiplePdnHandover-regular",
],
},
"sgwrelo" => {
"description" => "SGW Relocation",
"suites" => [
"s1HandoverRelocation-regular",
"multiApnS1HOReloc-regular",
"x2HandoverRelocation-regular",
"multiApnS1HORelocV6-regular",
"mmeRelocNoSGWReloc-regular",
],
},
"mmerelo" => {
"description" => "MME Relocation",
"suites" => [
"mmeRelocNoSGWRelocHA-regular",
],
},
"paging" => {
"description" => "Paging",
"suites" => [
"pagingSgwOnly-regular",
"pagingSgwPgw-regular",
"pagingMpdn-regular",
"pagingMpdnIdleToActive-regular",
"pagingMpdnIdleToActiveHA-regular",
],
},
"idlesesstimeout" => {
"description" => "Idle Session Timeout",
"suites" => [
"lteRadIdleSesTimeout-regular",
"pgwGaIdleSesTimeout-regular",
"lteIdleSesTimeout-regular",
],
},
"s2b" => {
"description" => "S2b",
"suites" => [
"lteS2bCallFlows-regular",
"s2bLteIRATHandover-regular",
"s2b3gLteCcauPendingICR-regular",
"s2bTo3gHoRatWlanICR-regular",
"pgwS6bS2bVzWCallFlows-extensive",
],
},
"redicr" => {
"description" => "Red/ICR",
"suites" => [
"mgRedundancyAll-medium",
"pgwIcrCallFlows-regular",
"lteGeoRedundancy-medium",
],
},
"irat" => {
"description" => "IRAT - No EHRPD/LTE handovers",
"suites" => [
"gnGxInterRatGprsLte-regular",
"ggsnUpdatePdp-regular",
"interRatGprsLteSgwHA-regular",
"ggsnCallFlowsHA-regular",
"interRatGprsLte-regular",
"interRatGprsLteMultiBr-regular",
"s2bLteIRATHandover-regular",
"s2bLteIRATHoWithHA-regular",
],
},
"li" => {
"description" => "LI",
"suites" =>  [
"Li_CallFlows-regular",
"lteLiSgwPgwAll-regular",
"lteLiGGSN-regular",
"lteLiGgsnMsisdn-regular",
"lteLiGgsnMultipleTargets-regular",
"lteLiSccg-regular",
],
},
"timeofday" => {
"description" => "Time of Day",
"suites" => [
"lteGxTimeOfDay-regular",
"lteGxTimeOfDayGeoRed-regular",
"lteGxTimeOfDayScaling-regular",
],
},
"usage" => {
"description" => "Usage Monitoring",
"suites" => [
"gxUsgMonitorAll-regular",
"gxRuleLevelUsageMonitoring-regular",
"gxRuleLevelUsageMonitoringWithRf-regular",
"gxRuleReferenceUsageMonitoring-regular",
"gxTimeBasedUsageMonitoring-regular",
"gxTimeBasedUsageMonitoringHA-regular",
"gxRuleLevelTimeUsageMonitoring-regular",
"gxUsageMonitoringGeoRed-regular",
"gxRuleLevelUsageMonitoringGeoRed-regular",
],
},
"charging" => {
"description" => "Charging (general)",
"suites" => [
"chargingAll-medium",
"lteBasicOnlineCharging-regular",
"pdnLevelOnlineCharging-regular",
"lteBasicOnlineOfflineChaStaticPol-regular",
"ggsnBasicOnlineOfflineChaDynamicPol-regular",
"onlineChargingDccaVersion2-regular",
"lteBasicOnline2-regular",
],
},
"ocfuiredirect" => {
"description" => "Online Charging - FUI Redirect",
"suites" => [
"ggsnFUIRedirectDPI-regular",
"ggsnFUIRedirectStaticPol-regular",
"lteFUIRedirectDPI-regular",
"redirectOnlineChargingDPI-regular",
"cuRedirectOnlineCharging-regular",
"nonFPTRedirect-regular",
],
},
"ocfuiterm" => {
"description" => "Online Charging - FUI Terminate",
"suites" => [
"lteFUITerminate-regular",
"lteFUITerminateStaticPol-regular",
"ggsnFUITerminate-regular",
"ggsnFUITerminateStaticPol-regular",
"cuTerminateOnlineCharging-regular",
],
},
"home" => {
"description" => "Home Agent",
"suites" => [
"mgHomeAgentCallFlows-regular",
"mgHaRadiusAuthScenarios-regular",
"mgHomeAgentOnlineCharging-regular",
],
},
"epdg" => {
"description" => "EPDG",
"suites" => [
"mgEpdgAll-medium",
"ePdgICRCallFlows-regular",
"ePdgWithoutICR-regular",
"ePdgDnsWithoutICR-regular",
"mgSwmWithoutICR-regular",
"ePdgRfChargingProfile-regular",
"ePdgRfTriggers-regular",
"ePdgRfMultiPdn-regular",
"ePdgGaChargingProfile-regular",
"ePdgGaTriggers-regular",
"ePdgGaMultiPdn-regular",
],
},
"twag" => {
"description" => "TWAG",
"suites" => [
"mgTwagAll--medium",
"twagOpenSSIDBasicCallFlows--medium",
],
},
"dslBonding" => {
"description" => "DSL Bonding",
"suites" => [
"lteDslBondingCallFlows-regular",
"lteDslBondingComboGw-regular",
"lteDslBondingPolicy-regular",
"lteDslBondingPolicySCCG-regular",
"lteChargingDslBonding-regular",
"lteSccgChargingDslBonding-regular",
],
},
"sponsorData" => {
"description" => "Sponsor Data",
"suites" => [
"pgwGaSponsoredConn-regular",
"pgwGaStaticSponsoredConnHA-regular",
"pgwGaAttachDetachICRsponConn-regular",
"pgwGaAttachDetachICRsponConnOffline-regular",
],
},
"pco" => {
"description" => "PCO",
"suites" => [
"ggsnPco-extensive",
"ltePCOSgwPgw-extensive",
"configurableGtpv2ExclPCO-regular",
],
},
"ueping" => {
"description" => "UE Ping",
"suites" => [
"mg1205OamUePing--regular",
"mg1205OamUePingCombo--regular",
"mg1205OamUePingCombo2Mscp--regular",
"oamUePingCallflows--regular",
],
},
"dns" => {
"description" => "DNS",
"suites" => [
"ePdgWithoutICR--regular",
"ePdgDnsWithoutICR--regular",
"ePdgICRDnsLoadControl--regular",
"ltePcscfRecovery--regular",
"ePdgICRDnsPgwScaling--regular",
],
},
"cups" => {
"description" => "CUPS",
"suites" => [
"cupsBasicCallFlows-regular",
"cupsBasicCharging-regular",
"cupsApnMgr-regular",
"cupsBasicLi-regular",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "cupsThreeDut",
},
],
},
"cupsBasic" => {
"description" => "CUPS BASIC",
"suites" => [
"cupsBasicCallFlows-regular",
"cupsPolicySanity-regular",
"cupsBasicCharging-regular",
"cupsBasicLi-regular",
"cupsBasicChargingImsPgw-regular",
"cupsApnMgr-regular",
"cupsUPSelection-regular",
"cupsPagingUpBuffering-regular",
],
"topos" => [
{
"sub" => "vfp",
"phys" => "cupsThreeDut",
},
],
},
"cupsDb" => {
"description" => "CUPS DB",
"suites" => [
"cupsDbBasicSuite-regular",
"cupsBasicChargingCdb-regular",
"cupsBasicChargingImsPgwCdb-regular",
"cupsBasicCallFlows-regular",
],
"topos" => [
{
"sub" => "dbNK",
"phys" => "cupsThreeDut",
},
],
"addargs" => "-preGashCmd gash/tools/cmg/copycmgimages.sh",
},
);
our $testflag = 0;
my $printOnly = 0;
my $sys = new sysInfo;
my $numCPU = $sys->getCPUcount();
# within the programmed 
my $fm = new forkMgr; 
$fm->config( $numCPU ); # Program Max CPUs (= max 
sub scheduleRegress
{
my $pkg = $main::package;
if( $main::dflag) {printf("Input Package is $pkg\n");}
if( $printOnly == 0 ) {
printf("Available testbeds $testBeds::tcount\n");
}
if( $pkg =~ /,/ ) {
$pkg =~ s/\s+//g;  
my @values = split(',', $pkg);
my $num = $#values + 1;
printf("Num of packages to regress $num\n");
for my $cnt (0 .. $#values ) {
printf("\n\tRegress Package: $values[$cnt]\n");
do_schedule($values[$cnt]);
}
} else {
printf("\n\tRegress Package: $pkg\n");
do_schedule($pkg);
}
unless( $main::dryOnly ) {
#sleep(1);
#printf("Waiting for results . . .\n\n");
$fm->wrapUp();
}
}
sub do_schedule
{
my $pkg = shift;
unless (exists $packages{$pkg}) {
printf("Unknown package $pkg\n");
return;
}
my @suites = @{$packages{$pkg}{"suites"}};
if (exists $packages{$pkg}{"addargs"}) {
$main::addargs.= " $packages{$pkg}{'addargs'} ";
}
if( $main::testTeam == 1 ) {
doitTestTeam(@suites);
return;
}
my @topos;
if (exists $packages{$pkg}{"topos"}) {
@topos = @{$packages{$pkg}{"topos"}};
} else {
@topos = (
{
"sub" => $main::subTopology,
"phys"=> $main::physTopology,
},
);
}
my %doneTopo = ();
for my $cnt (0 .. $#topos) {
my $topo = $topos[$cnt];
my $topoParams = "";
if ($main::subTopChosen) {
$topo->{"sub"} = $main::subTopology;
}
if ($main::physTopChosen) {
$topo->{"phys"} = $main::physTopology;
}
$topoParams = "$topo->{'sub'} $topo->{'phys'}";
unless (exists $doneTopo{$topoParams}) {
$doneTopo{$topoParams} = 1;
doit(\@suites, $topo);
}
}
}
my $testbed = "";
sub doit
{
my $suitesRef = shift;
my $topoRef = shift;
my @suites = @{$suitesRef};
my $numsuites = scalar(@suites);
my $dir = cwd();
my $strs = "";
my $str = "";
my $comboTest = "";
if( $testflag == 1 ) {
$strs = "Tests";
$str = "Test";
} else {
$strs = "Suites";
$str = "Suite";
}
printf("\t\tNum of $strs to regress $numsuites\n");
for my $cnt (0 .. $#suites) {
my $regress = "regress";
my ($suite, $runlevel) = getTestAndRunLevel($suites[$cnt]);
if( $printOnly ) {
my $num = $cnt + 1;
printf("\t\t$num: $str: $suite\trunLevel: $runlevel\n");
} else {
if( $testBeds::select ) {
printf("\n\t\tSelect Testbed for $str: $suite Runlevel $runlevel");
$testbed = testBeds::selectTestBed("ANY");
unless( $testbed ) {
printf("\t\tAuto assign testbed . . .\n");
$testbed = testBeds::getTestBed("ANY");
}
}
chdir($main::root);
unless( $testBeds::select ) {
if( $topoRef->{"sub"} eq "vfp" ) {
$testbed = testBeds::getTestBed("VM");
} else {
$testbed = testBeds::getTestBed("ANY");
}
}
my $rc = runRegressCmd($suite, $runlevel, $testbed, "run$str", $topoRef);
if( $rc != 0 ) {
$cnt = $cnt - 1;
}
}
}
chdir($dir);
}
sub doitTestTeam
{
my @array = @_;
my $numsuites = scalar(@array);
my $strs = "Suites";
my $str = "Suite";
printf("\t\tNum of $strs to regress $numsuites\n");
for my $cnt (0 .. $#array) {
my ($suite, $runlevel) = getTestAndRunLevel($array[$cnt]);
if( $printOnly ) {
printf("\t$str: $suite Runlevel $runlevel\n");
} else {
my %topo = ();
$testbed = testBeds::getTestBed("VM");
$topo{"sub"} = "";
runRegressCmd($suite, $runlevel, $testbed, "run$str", \%topo);
$testbed = testBeds::getTestBed("VM");
$topo{"sub"} = "ismMgB";
runRegressCmd($suite, $runlevel, $testbed, "run$str", \%topo);
$testbed = testBeds::getTestBed("SIM");
$topo{"sub"} = "";
runRegressCmd($suite, $runlevel, $testbed, "run$str", \%topo);
$testbed = testBeds::getTestBed("SIM");
$topo{"sub"} = "ismMgB";
runRegressCmd($suite, $runlevel, $testbed, "run$str", \%topo);
$topo{"sub"} = "";
runRegressCmd($suite, $runlevel, "mvltetb3", "run$str", \%topo);
$topo{"sub"} = "ismMgB";
runRegressCmd($suite, $runlevel, "mvltetb4", "run$str", \%topo);
}
if ($numsuites > 1 ) {
testBeds::findTestBeds();
}
}
}
sub runRegressCmd
{
my $suite = shift;
my $runlevel = shift;
my $testbed = shift;
my $run = shift;
my $topo = shift;
if( $testbed eq "" ) {
printf("Invalid Testbed [$testbed]\n");
return(-1);
}
my $regress = "regress";
if( $main::testTeam == 1 ) {
$regress = "$main::root/regress";
}
my $cmd = "";
if( $suite eq "express" ) {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -reason \"$main::reason\" ";
if( $main::testTeam == 1 ) {
$main::smgrTest = 0;
$main::acctTest = 0;
} else {
if( $topo->{"sub"} eq "" ) {
$main::smgrTest = 0;
$main::acctTest = 0;
}
}
if( $main::smgrTest ) {
$cmd .= "-smgrRunExpress true ";
}
if( $main::acctTest ) {
$cmd .= "-acctRunExpress true ";
}
} elsif( $suite eq "priority" ) {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -reason \"$main::reason\" ";
if( $main::startPriority ) {
$cmd .= "-startPriority $main::startPriority ";
} else {
die("-startPriority is $main::startPriority - error\n");
}
if( $main::endPriority ) {
$cmd .= "-endPriority $main::endPriority ";
} else {
die("-endPriority is $main::endPriority - error\n");
}
} else {
$cmd = "$regress -testbed $testbed -runLevel $runlevel -$run $suite -reason \"$main::reason\" ";
}
if( $suite eq "chargingAll" ) {
$cmd .= "-subTopology mgScalingV3 ";
} elsif ( $suite =~ /twag/ ) {
$cmd .= "-subTopology plasmaMgV3 ";
} elsif ( $topo->{"sub"} ne "" ) {
$cmd .= "-subTopology $topo->{'sub'} ";
}
if ($topo->{"phys"}  ne "") {
$cmd .= "-physTopology $topo->{'phys'} ";
}
if( $main::testTeam == 1 || main::globalRoot() ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest/ ";
if( $main::customGash ne "" ) {
$cmd .= "-customGash $main::customGash ";
}
$cmd .= "-emailMode result ";
} else {
if($main::latest == 1 ) {
if($main::ptrCheck == 1 ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest_p/ ";
} else {
if( $main::release eq "0.0" ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest/ ";
} else {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/latest_s/ ";
}
}
}
if($main::current == 1 ) {
if($main::ptrCheck == 1 ) {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/ptr-current/ ";
} else {
$cmd .= "-useimages /usr/global/images/7750mg/$main::release/current/ ";
}
}
if($main::current == 1 ) {
}
$cmd .= "-nobuild ";
}
if( $main::regressDbg == 1 ) {
$cmd .= "-debugOnFailure tkcon -exitOnFailure true ";
}
if( $main::addargs ) {
$cmd .= "$main::addargs ";
}
#$cmd .= "> /dev/null 2>&1";
#$cmd .= "> $rfile 2>&1";
if($main::dflag) { printf("$cmd\n"); }
unless ( $fm->fork() ) {
if( $main::dryOnly ) {
printf("\t\t[Pid: $$] Scheduling $suite/$runlevel/$topo->{'sub'}/$topo->{'phys'} @ $testbed ..\n");
printf("\t\t\t$cmd .. Dry\n");
exit(0);
} else {
my $rfile = "/tmp/regress$$.status";
printf("\t\t[Pid: $$] Scheduling $suite/$runlevel/$topo->{'sub'}/$topo->{'phys'} @ $testbed ..\n");
system( "$cmd > $rfile 2>&1" );
if( -e $rfile ) {
my $status = `cat $rfile | grep "Regression test submitted"`;
if ($status) {
printf("\t\t[Pid: $$] Done $suite/$runlevel/$topo->{'sub'}/$topo->{'phys'} @ $testbed\n");
unlink($rfile);
exit(0);
} else {
printf("\t\t[Pid: $$] Failed $suite/$runlevel/$topo->{'sub'}/$topo->{'phys'} @ $testbed\n");
if( $main::dflag ) {
printf("Regress Output:\n");
system("cat $rfile");
}
unlink($rfile);
exit(-1);
}
}
}
}
}
sub dumpPackages
{
my $num = 1;
printf("\tNum\t%-35s\tCode\n", "Package Desc.");
printf("\t-------------------------------------------------------------\n");
foreach my $pkg (sort keys %packages) {
if (defined $packages{$pkg}{"hidden"}) {
next;
}
printf("\t$num\t%-35s\t$pkg\n", $packages{$pkg}{"description"});
$num++;
}
printf("\t-------------------------------------------------------------\n");
}
sub dumpPkgDetails
{
if( $main::package eq "" ) {
printf("Package code missing, please provide from below:\n");
dumpPackages();
return;
}
printf("Package $main::package:\n");
$printOnly = 1;
scheduleRegress();
}
sub getTestAndRunLevel
{
my $testAndLevel = shift;
my $test = "";
my $level = "";
my @values = split('-', $testAndLevel);
if (scalar(@values) > 1) {
$level = $values[-1];
splice(@values, -1, 1);
$test = join("-", @values);
} else {
$test = $values[0];
$level = "regular";
}
return ($test, $level);
}
1;
package main;
my $version="v34.2";
use strict;
use Cwd;
our $dflag = 0;
our $dryOnly = 0;   
our $showtb = 0;    
our $noping = 1;    
our $vmonly = 0;    
our $allowhw = 0;   
our $hwonly = 0;    
our $simonly = 0;   
our $smgrTest = 0;  
our $acctTest = 1;  
our $latest = 0;    
our $current = 0;    
our $ptrCheck = 0;    
our $subTopology = "ismMgV3";    
our $subTopChosen = 0; 
our $physTopology = "lteDefault"; 
our $physTopChosen = 0; 
our $regressDbg = 0;    
our $startPriority = 0;    
our $endPriority = 0;    
our $addargs = "";
our $user = "";     
our $root = "";     
our $site = "";     
our $server = "";   
our $login = "";    
our $passwd = "";   
our $package = "";  
our $reason = "";
our $testTeam = 0;
our $customGash = "";
our $release = "0.0";
parseArgs();
unless( $package ) {
unless( $showtb ) {
printf("Nothing to run\n");
printf("For help, Enter: $0 -h\n");
exit;
}
}
$user = `whoami`;
chomp($user);
unless ($root ) {
getRoot();
}
getSite();
getCvsTag();
regressParams::getRegressParams();
testBeds::readBlacklist();
testBeds::findTestBeds();
unless ($reason) {
$reason = "$root :$version";
}
runSuite::scheduleRegress();
exit;
sub getRoot
{
my $dir = cwd();
chomp($dir);
if( $dir =~ /panos/ ) {
if( $dir =~ /panos\// ) {
$dir =~ /(.*)\/panos\/(.*)/;
$root = "$1/panos/";
} else {
$root = $dir;
}
if( $dflag ) {printf("WS: $root\n");}
return;
}
my @dirs = `find -O3 /home/$user -type d -name \"panos\" -print -prune`;
unless(@dirs) {
my $rc = `ls -la /usr/global/bin 2>/dev/null`;
if( $rc ) {
$root = "/usr/global/bin";
return;
}
}
my $index = 1;
if( $dir =~ /panos/ ) {
for my $choice (@dirs) {
chomp($dirs[$index - 1]);
if( $dflag ) {printf("Comparing $dir and $dirs[$index - 1]\n");}
if( $dirs[$index - 1] =~ /$dir/ ) {
$root = $dirs[$index - 1];
if( $dflag ) {printf("WS: $root\n");}
return;
}
$index++;
}
}
$index = 1;
for my $choice (@dirs) {
chomp($dirs[$index - 1]);
printf("$index) $dirs[$index - 1]\n");
$index++;
}
print "Enter your ($user) ws choice: ";
my $choice = <STDIN>;
chomp($choice);
unless( $choice > 0 && $choice < $index ) {
die("Invalid input $choice - please try again\n");
}
$root = $dirs[$choice - 1];
chomp($root);
if( $dflag ) {printf("WS: $root\n");}
}
sub getSite
{
unless( $site eq "" ) {
printf("Location: $site\t");
return;
}
my $cmd = "/usr/local/timostools/usertosite.sh $user 2>/dev/null";
my $output = `$cmd`;
chomp($output);
unless( $output ) {
if( globalRoot() ) {
return;
}
die("Unable to get location for $user\n");
}
setSite($output);
printf("Location: $output\t");
}
sub globalRoot
{
if( $root eq "/usr/global/bin" ) {
return(1);
}
return(0);
}
sub setSite
{
my $input = shift;
if ($input eq "MtnView") {
$site = "mvlte";
return;
}
if ($input eq "Bratislava") {
$site = "ba";
return;
}
if ($input eq "Naperville") {
$site = "npv";
return;
}
if ($input eq "Athens") {
$site = "ath";
return;
}
if ($input eq "Espoo") {
$site = "es"
}
}
sub setServers
{
my $input = shift;
if ($input eq "MtnView") {
$server = "mvltevm01.us.alcatel-lucent.com";
$login = "mvltevm01";
$passwd = "tigris";
return;
}
if ($input eq "Bratislava") {
$server = "baltehwrtb01.lab.sk.alcatel-lucent.com";
if( testBeds::_isAlive($server) ) {
$login = "baltehwrtb01";
} else {
printf("$server down - trying again\n");
$server = "baltehwrtb02.lab.sk.alcatel-lucent.com";
if( testBeds::_isAlive($server) ) {
$login = "baltehwrtb02";
} else {
die("Can not get Test Bed status - $server down\n");
}
}
$passwd = "tigris";
return;
}
if ($input eq "Naperville") {
$server = "npvgui.ih.lucent.com";
$login = "npvgui";
$passwd = "tigris";
return;
}
if ($input eq "Athens") {
$server = "athrtb2vm01.athmg.eecloud.dynamic.nsn-net.net";
$login = "athrtb2vm01";
$passwd = "tigris";
return;
}
if ( $input eq "Espoo" ) {
$server = "esrtb2vm01.dev.cic.nsn-rdnet.net";
$login = "esrtb2vm01";
$passwd = "tigris";
return;
}
}
sub getCvsTag
{
my $cvsfile = "$main::root/CVS/Tag";
my $lab = "";
my $data = `git symbolic-ref --short HEAD`;
unless ($data =~ /TiMOS-MG_/) {
$data = `git for-each-ref --format='%(upstream:short)' \$(git symbolic-ref -q HEAD)`;
if ($data =~ /(TiMOS-MG_.*)/) {
$data = $1;
}
}
chomp($data);
$data =~ s/TiMOS-MG_//g;
$data =~ s/_current//g;
$release = $data;
$release =~ s/_/./g;
printf("Release: $release\n");
}
sub parseArgs
{
my @T = @ARGV;
my $argTest = 0;
if ( scalar @T == 0 ) {
printf("Must supply one or more parameters\n");
printf("For more help, Enter: $0 -h\n");
exit(0);
}
while( my $a = shift(@T) ) {
if ( $a eq "-h" ) {
help();
exit(0);
}
if ( $a eq "-v" ) {
printf("VERSION: $version\n");
exit(0);
}
if ( $a eq "-d" ) {
$dflag = 1;
next;
}
if ( $a eq "-dry" ) {
$dryOnly = 1;
next;
}
if ( $a eq "-showtb" ) {
$showtb = 1;
next;
}
if ( $a eq "-suite" ) {
my $iput = shift(@T);
if($dflag) { printf("Input: [$iput]\n"); }
if( $iput =~ /,/ ) {
$iput =~ s/\s+//g;  
my @values = split(',', $iput);
for my $cnt (0 .. $#values ) {
if($dflag) { printf("Suite-RunLevel: $values[$cnt]\n"); }
push(@{$runSuite::packages{"custom"}{"suites"}}, $values[$cnt]);
}
} else {
if($dflag) { printf("Suite-RunLevel: $iput\n"); }
push(@{$runSuite::packages{"custom"}{"suites"}}, $iput);
}
$package = "custom";
next;
}
if ( $a eq "-runTest" ) {
my $iput = shift(@T);
my %comboTest = ();
if($dflag) { printf("Input: [$iput]\n"); }
if( $iput =~ /,/ ) {
$iput =~ s/\s+//g;  
my @values = split(',', $iput);
for my $cnt (0 .. $#values ) {
my $testRun = $values[$cnt];
if($dflag) { printf("Test-RunLevel: $testRun\n"); }
my ($test, $runLvl) = runSuite::getTestAndRunLevel($values[$cnt]);
unless( $comboTest{$runLvl} ) {
$comboTest{$runLvl} = $test;
} else {
$comboTest{$runLvl} = $comboTest{$runLvl}." $test";
}
#printf(" $comboTest{$runLvl}\n");
}
foreach my $key (keys %comboTest ) {
push(@{$runSuite::packages{"runtest"}{"suites"}}, "$comboTest{$key}-$key");
#printf("Adding $comboTest{$key}-$key\n");
}
} else {
if($dflag) { printf("test-RunLevel: $iput\n"); }
push(@{$runSuite::packages{"runtest"}{"suites"}}, $iput);
}
$package = "runtest";
$runSuite::testflag = 1;
next;
}
if ( $a eq "-pkg" ) {
$package = shift(@T);
next;
}
if ( $a eq "-st" ) {
$testBeds::select = 1;
next;
}
if ( $a eq "-nost" ) {
$testBeds::noselect = 1;
next;
}
if ( $a eq "-reason" || $a eq "-title" ) {
$reason = shift(@T);
$reason = $reason." :$version";
next;
}
if ( $a eq "-vm" ) {
$vmonly = 1;
next;
}
if ( $a eq "-hw" ) {
$hwonly = 1;
$allowhw = 1;
next;
}
if ( $a eq "-sim" ) {
$simonly = 1;
next;
}
if ( $a eq "-ping" ) {
$noping = 0;
next;
}
if ( $a eq "-nosmgr" ) {
$smgrTest = 0;
next;
}
if ( $a eq "-noacct" ) {
$acctTest = 0;
next;
}
if ( $a eq "-smgr" ) {
$smgrTest = 1;
next;
}
if ( $a eq "-acct" ) {
$acctTest = 1;
next;
}
if ( $a eq "-latest" ) {
$latest = 1;
next;
}
if ( $a eq "-current" ) {
$current = 1;
next;
}
if ( $a eq "-start" ) {
$startPriority = shift(@T);
next;
}
if ( $a eq "-end" ) {
$endPriority = shift(@T);
push(@runSuite::custom, "priority");
$package = "custom";
next;
}
if ( $a eq "-ptr" ) {
$ptrCheck = 1;
next;
}
if ( $a eq "-addargs" ) {
$addargs = shift(@T);
next;
}
if ( $a eq "-showpkg" ) {
$package = shift(@T);
runSuite::dumpPkgDetails();
exit;
}
if ( $a eq "-panos" || $a eq "-root" || $a eq "-ws" ) {
$root = shift(@T);
next;
}
if ( $a eq "-v1" ) {
$subTopology = "";
$subTopChosen = 1;
next;
}
if ( $a eq "-site" ) {
$site = shift(@T);
if( $site eq "mv" ) {
setSite("MtnView");
setServers("MtnView");
} elsif ($site eq "ba") {
setSite("Bratislava");
setServers("Bratislava");
} elsif ($site eq "npv") {
setSite("Naperville");
setServers("Naperville");
} elsif ($site eq "ath") {
setSite("Athens");
setServers("Athens");
} elsif ($site eq "es") {
setSite("Espoo");
setServers("Espoo");
} else {
die("Incorrect site mentiond (mv, npv, ba, ath, es allowed)");
}
next;
}
if ( $a eq "-v2" ) {
$subTopology = "ismMgB";
$subTopChosen = 1;
next;
}
if ( $a eq "-v3" ) {
$subTopology = "ismMgV3";
$subTopChosen = 1;
next;
}
if ( $a eq "-plasma" ) {
$subTopology = "plasmaMgV3";
$subTopChosen = 1;
next;
}
if ( $a eq "-vfp" ) {
$subTopology = "vfp";
$subTopChosen = 1;
$runSuite::vfp = 1;
next;
}
if ( $a eq "-sub" ) {
$subTopology = shift(@T);
$subTopChosen = 1;
next;
}
if ( $a eq "-regressDbg" ) {
$regressDbg = 1;
next;
}
if ( $a eq "-test" ) {
$testTeam = 1;
$root = "/usr/global/bin";
next;
}
if ( $a eq "-customGash" ) {
$customGash = shift(@T);
next;
}
if ( $a eq "-rel" ) {
$release = shift(@T);
next;
}
if ( $a eq "-all" ) {
$testBeds::allowAllTb = 1;
next;
}
if ( $a eq "-phys" ) {
$physTopology = shift(@T);
$physTopChosen = 1;
next;
}
die("Unknown Command Line Option: '$a'\n");
}
}
sub help
{
printf("Following parameters are supported:\n");
printf("\t-root <ws>: Provide workspace or you will be asked if not already in ws\n");
printf("\t-site <site>: Provide mv / ba / npv / ath / es for MtnView, Bratislava, Naperville, Athens or Espoo sites\n");
printf("\t-pkg <code>: Provide pkg code to run regressions\n");
printf("\t-suite <suite-runLevel>: Provide suite name and runlevel\n");
printf("\t-runTest <test>: Provide test name and runlevel\n");
printf("\t-reason <reason>: Provide reason to run regressions (optional default takes WS)\n");
printf("\t-addargs <args>: Provide additional regress arguments besides already supported\n");
printf("\t-nosmgr: Run express with SMGR test infra off (Default on)\n");
printf("\t-noacct: Run express with ACCT test infra off (Default on)\n");
printf("\t-smgr: Run express with SMGR test infra on (Default on)\n");
printf("\t-acct: Run express with ACCT test infra on (Default on)\n");
printf("\t-latest: Run package with latest image instead of local panos\n");
printf("\t-current: Run package with current image instead of local panos\n");
printf("\t-ptr: Run package with latest or current ptrCheck image instead of local panos\n");
printf("\t-start: Specify startPriority instead of suite/test\n");
printf("\t-end: Specify endPriority instead of suite/test\n");
printf("\t-regressDbg: Debug regress run - stop on error\n");
printf("\t-v1: Do not use subTopology option\n");
printf("\t-v2: Use subTopology ismMgB (Default)\n");
printf("\t-v3: Use subTopology ismMgV3\n");
printf("\t-vfp: Use subTopology vfp\n");
printf("\t-sub <subTopology>: Provide subTopology\n");
printf("\t-phys <physTopology>: Provide physTopology\n");
printf("\t-vm : If used, only VM testbeds will used\n");
printf("\t-hw : If used, only HW testbeds will used\n");
printf("\t-sim : If used, only SIM testbeds will used\n");
printf("\t-ping : If used, ping testbeds before selection\n");
printf("\t-st : Select a testbed instead of random pickup of one\n");
printf("\t-nost : Auto select a testbed even if no idle\n");
printf("\t-all: Show private/reserved testbeds also\n");
printf("\n\t-test: For test team use (express, quick or basic only)\n");
printf("\t-customGash <tag>: For test team if they need custom gash\n");
printf("\t-rel <release>: For test team if they need specific release images default 0.0\n");
printf("\n\t-dry: Dry run - just shows regress commands\n");
printf("\t-showpkg <code>: Show suites and levels in a pkg code\n");
printf("\t-showtb : Show available testbeds only\n");
printf("\t-v: Dumps the version\n");
printf("\t-d: turn on debug\n");
printf("\t-h: This help menu\n");
printf("\nSupported Packages and their codes:\n");
runSuite::dumpPackages();
printf("\nExample 1:\n");
printf("\tTo run express and quick:\n\t$0 -pkg basic\n");
printf("\nExample 2:\n");
printf("\tWith reason:\n\t$0 -pkg basic -reason \"DTSxxxx\"\n");
printf("\nExample 3:\n");
printf("\tRun multiple packages:\n\t$0 -pkg basic,combo -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -pkg \"basic, combo\" -reason \"DTSxxxx\"\n");
printf("\nExample 4:\n");
printf("\tRun using Custom Suite:\n\t$0 -suite mgQuick-quickOnly -reason \"DTSxxxx\"\n");
printf("\nExample 5:\n");
printf("\tRun multiple Custom Suite:\n\t$0 -suite mgQuick-quickOnly,lteCallFlows-regular -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -suite \"mgQuick-quickOnly, lteCallFlows-regular\" -reason \"DTSxxxx\"\n");
printf("\nExample 6:\n");
printf("\tRun using Custom Test:\n\t$0 -runTest dedBrQciArpChTests_P0-regular -reason \"DTSxxxx\"\n");
printf("\nExample 7:\n");
printf("\tRun multiple Custom Tests:\n\t$0 -runTest dedBrQciArpChTests_P0-regular,dedBrQciArpChTests_P1-regular -reason \"DTSxxxx\"\n");
printf("\n\tOr: $0 -suite \"dedBrQciArpChTests_P0, dedBrQciArpChTests_P1\" -reason \"DTSxxxx\"\n");
printf("\nExample 8:\n");
printf("\tTo run express and quick using specific workspace:\n\t$0 -pkg basic -root /home/xxx/00/panos\n");
printf("\nExample 9:\n");
printf("\tShow detail contents of a package:\n\t$0 -showpkg basic\n");
}
